# è‡ªåŠ¨åŒ–AIä»»åŠ¡æ‰§è¡Œç³»ç»Ÿè®¾è®¡æ–‡æ¡£

## ğŸ“‹ ç³»ç»Ÿæ¦‚è§ˆ

### æ”¯æŒçš„ä»»åŠ¡ç±»å‹
æœ¬ç³»ç»Ÿæ”¯æŒä»¥ä¸‹5ç§ä»»åŠ¡ç±»å‹ï¼Œæ¯ç§ä»»åŠ¡éƒ½å¯ä»¥ç‹¬ç«‹é…ç½®å’Œè°ƒåº¦ï¼š

1. **ğŸ”§ ç¼–ç ä»»åŠ¡ (coding)**
   - AIè‡ªåŠ¨ç”Ÿæˆä»£ç ï¼Œæ”¯æŒåˆ†æ”¯åˆ›å»ºå’ŒGitæäº¤
   - ä¸èµ°æŸ¥ä»»åŠ¡åä½œï¼Œé€šè¿‡çŠ¶æ€æ–‡ä»¶åè°ƒæ‰§è¡Œæµç¨‹

2. **ğŸ” èµ°æŸ¥ä»»åŠ¡ (review)**
   - AIä»£ç å®¡æŸ¥ï¼Œåˆ†æä»£ç è´¨é‡å’Œè®¾è®¡åˆç†æ€§
   - æ”¯æŒåä½œæ¨¡å¼ï¼ˆä¸ç¼–ç ä»»åŠ¡é…åˆï¼‰å’Œç‹¬ç«‹æ¨¡å¼

3. **ğŸ“š æ–‡æ¡£ä»»åŠ¡ (doc)**
   - AIè‡ªåŠ¨ç”ŸæˆMarkdownæ ¼å¼æ–‡æ¡£
   - æ”¯æŒæŠ€æœ¯æ–‡æ¡£ã€APIæ–‡æ¡£ã€ç”¨æˆ·æ‰‹å†Œç­‰

4. **ğŸ“‹ éœ€æ±‚è¯„å®¡ä»»åŠ¡ (requirement_review)** â­ æ–°å¢
   - AIåˆ†æéœ€æ±‚æ–‡æ¡£ä¸ä»£ç å®ç°çš„ä¸€è‡´æ€§
   - æ·±å…¥åˆ†ææ¶æ„è®¾è®¡ã€æ¥å£å®šä¹‰ã€æ•°æ®æ¨¡å‹ç­‰

5. **âš™ï¸ è‡ªå®šä¹‰ä»»åŠ¡ (custom)** â­ æ–°å¢
   - æ”¯æŒä»»æ„åœºæ™¯çš„AIä»»åŠ¡ï¼Œé«˜åº¦çµæ´»
   - æ”¯æŒå¤šç§è¾“å‡ºæ ¼å¼ï¼ˆMarkdownã€Excelã€PPTç­‰ï¼‰

### æ ¸å¿ƒç‰¹æ€§
- **æ™ºèƒ½è°ƒåº¦**ï¼šåŸºäºcrontabè¡¨è¾¾å¼çš„å®šæ—¶ä»»åŠ¡æ‰§è¡Œ
- **AIé©±åŠ¨**ï¼šæ”¯æŒClaudeå’ŒDeepSeekç­‰å¤šç§AIæ¨¡å‹
- **Gité›†æˆ**ï¼šå®Œæ•´çš„GitHubå’ŒGitLabè‡ªåŠ¨åŒ–æ“ä½œ
- **çŠ¶æ€åè°ƒ**ï¼šæ™ºèƒ½çš„ä»»åŠ¡çŠ¶æ€ç®¡ç†å’Œåä½œæœºåˆ¶
- **é€šçŸ¥ç³»ç»Ÿ**ï¼šé’‰é’‰æœºå™¨äººå®æ—¶é€šçŸ¥å’Œå‘Šè­¦

### ä»»åŠ¡ç±»å‹å¯¹æ¯”è¡¨

| ä»»åŠ¡ç±»å‹ | ä¸»è¦åŠŸèƒ½ | è¾“å…¥æ¥æº | è¾“å‡ºæ ¼å¼ | åä½œå…³ç³» | å…¸å‹åº”ç”¨åœºæ™¯ |
|---------|---------|---------|---------|---------|-------------|
| **ç¼–ç ä»»åŠ¡** | AIä»£ç ç”Ÿæˆ | éœ€æ±‚æè¿°ã€ä»£ç ä¸Šä¸‹æ–‡ | ä»£ç æ–‡ä»¶ | ä¸èµ°æŸ¥ä»»åŠ¡åä½œ | åŠŸèƒ½å¼€å‘ã€ä»£ç é‡æ„ |
| **èµ°æŸ¥ä»»åŠ¡** | ä»£ç è´¨é‡å®¡æŸ¥ | ä»£ç å˜æ›´ã€ç¼–ç è§„èŒƒ | MarkdownæŠ¥å‘Š | ä¸ç¼–ç ä»»åŠ¡åä½œ | ä»£ç å®¡æŸ¥ã€è´¨é‡æ£€æŸ¥ |
| **æ–‡æ¡£ä»»åŠ¡** | æ–‡æ¡£è‡ªåŠ¨ç”Ÿæˆ | ä»£ç ã€éœ€æ±‚æè¿° | Markdownæ–‡æ¡£ | ç‹¬ç«‹æ‰§è¡Œ | æŠ€æœ¯æ–‡æ¡£ã€APIæ–‡æ¡£ |
| **éœ€æ±‚è¯„å®¡** | éœ€æ±‚ä¸ä»£ç ä¸€è‡´æ€§åˆ†æ | éœ€æ±‚æ–‡æ¡£ã€ä»£ç å®ç° | MarkdownæŠ¥å‘Š | ç‹¬ç«‹æ‰§è¡Œ | éœ€æ±‚éªŒè¯ã€æ¶æ„è¯„å®¡ |
| **è‡ªå®šä¹‰ä»»åŠ¡** | çµæ´»AIä»»åŠ¡ | è‡ªå®šä¹‰è¾“å…¥æº | å¤šç§æ ¼å¼ | ç‹¬ç«‹æ‰§è¡Œ | ä»£ç åˆ†æã€æŠ¥å‘Šç”Ÿæˆ |

## 1. ç³»ç»Ÿæ¶æ„æ¦‚è¿°

### 1.1 æ•´ä½“æ¶æ„
```mermaid
graph TD
    A[ä¸»ç¨‹åºå…¥å£] --> B[ä»»åŠ¡è°ƒåº¦å™¨]
    B --> C[ä»»åŠ¡æ‰§è¡Œå™¨]
    C --> D[AIæœåŠ¡ç®¡ç†å™¨]
    C --> E[Gitæ“ä½œç®¡ç†å™¨]
    C --> F[çŠ¶æ€åè°ƒå™¨]
    C --> G[é€šçŸ¥ç®¡ç†å™¨]
    
    H[é…ç½®æ–‡ä»¶] --> B
    H --> D
    H --> G
    
    I[å‘½ä»¤è¡Œå·¥å…·] --> B
    I --> C
    I --> F
    
    J[çŠ¶æ€æ–‡ä»¶] --> F
    K[æ—¥å¿—ç³»ç»Ÿ] --> C
```

### 1.2 æ ¸å¿ƒç»„ä»¶
- **ä»»åŠ¡è°ƒåº¦å™¨**ï¼šåŸºäºcrontabè¡¨è¾¾å¼çš„å®šæ—¶ä»»åŠ¡è°ƒåº¦ï¼Œæ”¯æŒ5ç§ä»»åŠ¡ç±»å‹ï¼Œæ”¯æŒä¼˜å…ˆçº§å’Œå¹¶å‘æ§åˆ¶
- **ä»»åŠ¡æ‰§è¡Œå™¨**ï¼šæ‰§è¡Œç¼–ç ã€èµ°æŸ¥ã€æ–‡æ¡£ç”Ÿæˆã€éœ€æ±‚è¯„å®¡ã€è‡ªå®šä¹‰ä»»åŠ¡ï¼Œæ”¯æŒè¶…æ—¶æ§åˆ¶å’Œé‡è¯•æœºåˆ¶
- **AIæœåŠ¡ç®¡ç†å™¨**ï¼šç®¡ç†Claudeå’ŒDeepSeek APIè°ƒç”¨ï¼Œæ”¯æŒä»»åŠ¡ç±»å‹ç‰¹å®šçš„å‚æ•°ä¼˜åŒ–
- **Gitæ“ä½œç®¡ç†å™¨**ï¼šå¤„ç†GitHubå’ŒGitLabæ“ä½œï¼Œæ”¯æŒåˆ†æ”¯ç®¡ç†å’Œä»£ç æäº¤
- **çŠ¶æ€åè°ƒå™¨**ï¼šåè°ƒç¼–ç è€…å’Œèµ°æŸ¥è€…çš„äº¤æ›¿æ‰§è¡Œï¼Œç®¡ç†ä»»åŠ¡çŠ¶æ€è½¬æ¢å’ŒçŠ¶æ€æ–‡ä»¶æ¸…ç†
- **é€šçŸ¥ç®¡ç†å™¨**ï¼šé’‰é’‰æœºå™¨äººé€šçŸ¥ï¼Œæ”¯æŒä¸ªæ€§åŒ–é€šçŸ¥æ¨¡æ¿å’Œå¤šç§é€šçŸ¥çº§åˆ«
- **é…ç½®ç®¡ç†å™¨**ï¼šç®¡ç†å…¨å±€å’Œä»»åŠ¡çº§é…ç½®ï¼Œæ”¯æŒç¼–ç è§„èŒƒã€è¶…æ—¶æ—¶é—´ã€é‡è¯•ç­–ç•¥ç­‰é…ç½®
- **ç¼–ç è§„èŒƒç®¡ç†å™¨**ï¼šæŒ‰è¯­è¨€åˆ†ç±»ç®¡ç†ç¼–ç è§„èŒƒæ–‡ä»¶ï¼Œæ”¯æŒç‰ˆæœ¬ç®¡ç†å’ŒåŠ¨æ€åŠ è½½
- **çŠ¶æ€æ–‡ä»¶ç®¡ç†å™¨**ï¼šç®¡ç†çŠ¶æ€æ–‡ä»¶çš„ç”Ÿå‘½å‘¨æœŸï¼Œæ”¯æŒè‡ªåŠ¨æ¸…ç†ã€å½’æ¡£å’Œå¤‡ä»½

## 2. ç³»ç»Ÿè®¾è®¡

### 2.1 ç›®å½•ç»“æ„
```
auto-coder/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/                 # æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ scheduler.py      # ä»»åŠ¡è°ƒåº¦å™¨
â”‚   â”‚   â”œâ”€â”€ executor.py       # ä»»åŠ¡æ‰§è¡Œå™¨
â”‚   â”‚   â”œâ”€â”€ state_manager.py  # çŠ¶æ€åè°ƒå™¨
â”‚   â”‚   â””â”€â”€ config_manager.py # é…ç½®ç®¡ç†å™¨
â”‚   â”œâ”€â”€ services/             # æœåŠ¡å±‚
â”‚   â”‚   â”œâ”€â”€ ai_service.py     # AIæœåŠ¡ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ git_service.py    # Gitæ“ä½œæœåŠ¡
â”‚   â”‚   â””â”€â”€ notify_service.py # é€šçŸ¥æœåŠ¡
â”‚   â”œâ”€â”€ tasks/                # ä»»åŠ¡ç±»å‹
â”‚   â”‚   â”œâ”€â”€ coding_task.py    # ç¼–ç ä»»åŠ¡
â”‚   â”‚   â”œâ”€â”€ review_task.py    # èµ°æŸ¥ä»»åŠ¡
â”‚   â”‚   â”œâ”€â”€ doc_task.py       # æ–‡æ¡£ä»»åŠ¡
â”‚   â”‚   â”œâ”€â”€ requirement_review_task.py  # éœ€æ±‚è¯„å®¡ä»»åŠ¡
â”‚   â”‚   â””â”€â”€ custom_task.py    # è‡ªå®šä¹‰ä»»åŠ¡
â”‚   â”œâ”€â”€ utils/                # å·¥å…·ç±»
â”‚   â”‚   â”œâ”€â”€ logger.py         # æ—¥å¿—å·¥å…·
â”‚   â”‚   â”œâ”€â”€ file_utils.py     # æ–‡ä»¶æ“ä½œå·¥å…·
â”‚   â”‚   â””â”€â”€ crypto_utils.py   # åŠ å¯†å·¥å…·
â”‚   â””â”€â”€ cli/                  # å‘½ä»¤è¡Œæ¥å£
â”‚       â””â”€â”€ main.py           # ä¸»ç¨‹åºå…¥å£
â”œâ”€â”€ config/                   # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ global_config.yaml    # å…¨å±€é…ç½®
â”‚   â””â”€â”€ tasks/                # ä»»åŠ¡é…ç½®
â”œâ”€â”€ standards/                # ç¼–ç è§„èŒƒæ–‡ä»¶
â”‚   â”œâ”€â”€ java_coding_standards.md      # Javaç¼–ç è§„èŒƒ
â”‚   â”œâ”€â”€ python_coding_standards.md    # Pythonç¼–ç è§„èŒƒ
â”‚   â”œâ”€â”€ frontend_coding_standards.md  # å‰ç«¯ç¼–ç è§„èŒƒ
â”‚   â”œâ”€â”€ general_coding_standards.md   # é€šç”¨ç¼–ç è§„èŒƒ
â”‚   â””â”€â”€ redline_standards.md          # ç¼–ç çº¢çº¿è§„èŒƒ
â”œâ”€â”€ logs/                     # æ—¥å¿—æ–‡ä»¶
â”œâ”€â”€ states/                   # çŠ¶æ€æ–‡ä»¶
â”œâ”€â”€ archives/                 # å½’æ¡£æ–‡ä»¶
â”‚   â””â”€â”€ states/               # çŠ¶æ€æ–‡ä»¶å½’æ¡£
â”œâ”€â”€ outputs/                  # è¾“å‡ºæ–‡ä»¶
â”‚   â”œâ”€â”€ reviews/              # ä»£ç å®¡æŸ¥è¾“å‡º
â”‚   â”œâ”€â”€ docs/                 # æ–‡æ¡£ç”Ÿæˆè¾“å‡º
â”‚   â”œâ”€â”€ requirement_reviews/  # éœ€æ±‚è¯„å®¡è¾“å‡º
â”‚   â””â”€â”€ custom_tasks/         # è‡ªå®šä¹‰ä»»åŠ¡è¾“å‡º
â”œâ”€â”€ requirements.txt           # ä¾èµ–åŒ…
â”œâ”€â”€ README.md                 # ä½¿ç”¨è¯´æ˜
â””â”€â”€ run.py                    # å¯åŠ¨è„šæœ¬
```

### 2.2 é…ç½®æ–‡ä»¶ç»“æ„

#### è°ƒåº¦é…ç½®æ ¼å¼è¯´æ˜

ç³»ç»Ÿæ”¯æŒä¸¤ç§è°ƒåº¦é…ç½®æ ¼å¼ï¼š

**1. æ ‡å‡†crontabè¡¨è¾¾å¼æ ¼å¼ï¼ˆæ¨èï¼‰**
```yaml
schedule:
  type: "cron"
  cron_expressions:
    - "0 9 * * 1-5"      # å‘¨ä¸€åˆ°å‘¨äº”ä¸Šåˆ9ç‚¹
    - "0 18 * * 1-5"     # å‘¨ä¸€åˆ°å‘¨äº”ä¸‹åˆ6ç‚¹
```

**2. åˆ†è§£çš„cronå­—æ®µæ ¼å¼ï¼ˆå‘åå…¼å®¹ï¼‰**
```yaml
schedule:
  type: "cron"
  cron:
    minute: "0"
    hour: "9"
    day: "*"
    month: "*"
    day_of_week: "1-5"
```

**crontabè¡¨è¾¾å¼æ ¼å¼è¯´æ˜ï¼š**
- æ ¼å¼ï¼š`åˆ†é’Ÿ å°æ—¶ æ—¥æœŸ æœˆä»½ æ˜ŸæœŸ`
- å­—æ®µï¼š`0-59 0-23 1-31 1-12 0-7`ï¼ˆ0å’Œ7éƒ½è¡¨ç¤ºå‘¨æ—¥ï¼‰
- ç‰¹æ®Šå­—ç¬¦ï¼š
  - `*`ï¼šè¡¨ç¤ºä»»æ„å€¼
  - `*/n`ï¼šè¡¨ç¤ºæ¯éš”nä¸ªå•ä½
  - `1-5`ï¼šè¡¨ç¤ºèŒƒå›´ï¼ˆ1åˆ°5ï¼‰
  - `1,3,5`ï¼šè¡¨ç¤ºæŒ‡å®šå€¼

#### å…¨å±€é…ç½®æ–‡ä»¶ (global_config.yaml)
```yaml
# AIæœåŠ¡é…ç½®
ai_services:
  claude:
    api_key: "${CLAUDE_API_KEY}"
    base_url: "https://api.anthropic.com"
    model: "claude-3-sonnet-20240229"
    max_tokens: 4000
    temperature: 0.1
    
    # é«˜çº§å‚æ•°
    parameters:
      temperature: 0.1
      max_tokens: 4000
      top_p: 0.9
      frequency_penalty: 0.0
      presence_penalty: 0.0
      stop_sequences: []
    
    # ä»»åŠ¡ç±»å‹ç‰¹å®šå‚æ•°
    task_parameters:
      coding:
        temperature: 0.05
        max_tokens: 6000
      review:
        temperature: 0.1
        max_tokens: 3000
      requirement_review:
        temperature: 0.15
        max_tokens: 5000
  
  deepseek:
    api_key: "${DEEPSEEK_API_KEY}"
    base_url: "https://api.deepseek.com"
    model: "deepseek-coder"
    max_tokens: 4000
    temperature: 0.1
    
    # é«˜çº§å‚æ•°
    parameters:
      temperature: 0.1
      max_tokens: 4000
      top_p: 0.9
      repetition_penalty: 1.0
      top_k: 40
    
    # ä»»åŠ¡ç±»å‹ç‰¹å®šå‚æ•°
    task_parameters:
      coding:
        temperature: 0.05
        max_tokens: 6000
      review:
        temperature: 0.1
        max_tokens: 3000
      requirement_review:
        temperature: 0.15
        max_tokens: 5000

# Gité…ç½®
git:
  github:
    token: "${GITHUB_TOKEN}"
    username: "${GITHUB_USERNAME}"
  gitlab:
    token: "${GITLAB_TOKEN}"
    base_url: "${GITLAB_BASE_URL}"

# ç¼–ç è§„èŒƒé…ç½®ï¼ˆæŒ‰è¯­è¨€åˆ†ç±»ï¼‰
coding_standards:
  java:
    file_path: "./standards/java_coding_standards.md"
    enabled: true
    description: "Javaç¼–ç è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"
  
  python:
    file_path: "./standards/python_coding_standards.md"
    enabled: true
    description: "Pythonç¼–ç è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"
  
  frontend:
    file_path: "./standards/frontend_coding_standards.md"
    enabled: true
    description: "å‰ç«¯ç¼–ç è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"
  
  general:
    file_path: "./standards/general_coding_standards.md"
    enabled: true
    description: "é€šç”¨ç¼–ç è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"
  
  redlines:
    file_path: "./standards/redline_standards.md"
    enabled: true
    description: "ç¼–ç çº¢çº¿è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"

# ä»»åŠ¡è¶…æ—¶æ—¶é—´é…ç½®
task_timeouts:
  coding: 1800      # 30åˆ†é’Ÿ
  review: 900       # 15åˆ†é’Ÿ
  doc: 600          # 10åˆ†é’Ÿ
  requirement_review: 1200  # 20åˆ†é’Ÿ
  custom: 1800      # 30åˆ†é’Ÿ
  
  global:
    default: 600    # é»˜è®¤è¶…æ—¶æ—¶é—´
    max: 7200       # æœ€å¤§è¶…æ—¶æ—¶é—´ï¼ˆ2å°æ—¶ï¼‰
    warning_threshold: 0.8  # è¶…æ—¶è­¦å‘Šé˜ˆå€¼

# é‡è¯•é…ç½®
retry_config:
  max_attempts: 3
  base_delay: 60
  max_delay: 3600
  backoff_multiplier: 2
  jitter: 0.1
  
  task_specific:
    coding:
      max_attempts: 5
      base_delay: 120
    git_operations:
      max_attempts: 3
      base_delay: 30

# çŠ¶æ€æ–‡ä»¶ç®¡ç†é…ç½®
state_management:
  cleanup_enabled: true
  retention_days: 90
  archive_enabled: true
  archive_path: "./archives/states"
  cleanup_schedule: "0 2 * * *"  # æ¯å¤©å‡Œæ™¨2ç‚¹æ¸…ç†
  
  cleanup_strategy:
    completed_tasks: "archive"
    failed_tasks: "archive"
    running_tasks: "skip"
    expired_tasks: "delete"
  
  archive:
    compression: true
    compression_format: "zip"
    max_archive_size: "100MB"
    archive_retention_days: 365
  
  state_file:
    max_size: "10MB"
    backup_enabled: true
    backup_count: 3
    backup_interval: "1h"

# é€šçŸ¥æ¨¡æ¿é…ç½®
notification_templates:
  variables:
    task_name: "{task_name}"
    task_type: "{task_type}"
    task_id: "{task_id}"
    duration: "{duration}"
    error_message: "{error_message}"
    files_count: "{files_count}"
    issues_count: "{issues_count}"
    inconsistencies_count: "{inconsistencies_count}"
  
  common:
    task_start: "ğŸš€ ä»»åŠ¡ {task_name} ({task_type}) å¼€å§‹æ‰§è¡Œ"
    task_complete: "âœ… ä»»åŠ¡ {task_name} æ‰§è¡Œå®Œæˆï¼Œè€—æ—¶ {duration}"
    task_error: "âŒ ä»»åŠ¡ {task_name} æ‰§è¡Œå¤±è´¥: {error_message}"
  
  task_specific:
    coding:
      start: "ğŸ”§ ç¼–ç ä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… ç¼–ç ä»»åŠ¡ {task_name} å®Œæˆï¼Œç”Ÿæˆäº† {files_count} ä¸ªæ–‡ä»¶"
      error: "âŒ ç¼–ç ä»»åŠ¡ {task_name} å¤±è´¥: {error_message}"
      review_required: "ğŸ” ç¼–ç ä»»åŠ¡ {task_name} å®Œæˆï¼Œç­‰å¾…ä»£ç å®¡æŸ¥"
    
    review:
      start: "ğŸ” ä»£ç å®¡æŸ¥ä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… ä»£ç å®¡æŸ¥å®Œæˆï¼Œå‘ç° {issues_count} ä¸ªé—®é¢˜"
      error: "âŒ ä»£ç å®¡æŸ¥å¤±è´¥: {error_message}"
      issues_found: "âš ï¸ ä»£ç å®¡æŸ¥å‘ç° {issues_count} ä¸ªé—®é¢˜ï¼Œéœ€è¦é‡æ–°ç¼–ç "
      no_issues: "âœ… ä»£ç å®¡æŸ¥é€šè¿‡ï¼Œä»»åŠ¡å®Œæˆ"
    
    doc:
      start: "ğŸ“š æ–‡æ¡£ç”Ÿæˆä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… æ–‡æ¡£ç”Ÿæˆå®Œæˆï¼Œè¾“å‡ºåˆ° {output_path}"
      error: "âŒ æ–‡æ¡£ç”Ÿæˆå¤±è´¥: {error_message}"
    
    requirement_review:
      start: "ğŸ“‹ éœ€æ±‚è¯„å®¡ä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… éœ€æ±‚è¯„å®¡å®Œæˆï¼Œå‘ç° {inconsistencies_count} ä¸ªä¸ä¸€è‡´ç‚¹"
      error: "âŒ éœ€æ±‚è¯„å®¡å¤±è´¥: {error_message}"
      critical_issues: "ğŸš¨ éœ€æ±‚è¯„å®¡å‘ç°å…³é”®é—®é¢˜ï¼Œè¯·åŠæ—¶å¤„ç†"
    
    custom:
      start: "âš™ï¸ è‡ªå®šä¹‰ä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… è‡ªå®šä¹‰ä»»åŠ¡ {task_name} æ‰§è¡Œå®Œæˆ"
      error: "âŒ è‡ªå®šä¹‰ä»»åŠ¡ {task_name} æ‰§è¡Œå¤±è´¥: {error_message}"
  
  notification_levels:
    info: ["task_start", "task_complete"]
    warning: ["review_required", "issues_found"]
    error: ["task_error", "critical_issues"]
  
  channels:
    dingtalk:
      enabled: true
      webhook_url: "${DINGTALK_WEBHOOK}"
      secret: "${DINGTALK_SECRET}"
      at_users: ["å¼ ä¸‰", "æå››"]
      at_all: false
    
    email:
      enabled: false
      smtp_server: ""
      smtp_port: 587
      username: ""
      password: ""
    
    webhook:
      enabled: false
      url: ""
      headers: {}

# é€šçŸ¥é…ç½®
notification:
  dingtalk:
    webhook_url: "${DINGTALK_WEBHOOK}"
    secret: "${DINGTALK_SECRET}"
    at_users: ["å¼ ä¸‰", "æå››"]

# æ—¥å¿—é…ç½®
logging:
  level: "INFO"
  retention_days: 30
  max_file_size: "10MB"

# ç³»ç»Ÿé…ç½®
system:
  work_dir: "./states"
  output_dir: "./outputs"
  max_concurrent_tasks: 5
  default_timeout: 300
```

#### ä»»åŠ¡é…ç½®æ–‡ä»¶ç¤ºä¾‹

##### ç¼–ç ä»»åŠ¡é…ç½® (tasks/coding_task.yaml)
```yaml
task_id: "feature_001"
name: "ç”¨æˆ·ç®¡ç†åŠŸèƒ½å¼€å‘"
type: "coding"
priority: 1
enabled: true

# è°ƒåº¦é…ç½®
schedule:
  type: "cron"
  cron_expressions:
    - "0 9 * * 1-5"      # å‘¨ä¸€åˆ°å‘¨äº”ä¸Šåˆ9ç‚¹æ‰§è¡Œ
    - "0 18 * * 1-5"     # å‘¨ä¸€åˆ°å‘¨äº”ä¸‹åˆ6ç‚¹æ‰§è¡Œ

# é¡¹ç›®é…ç½®
project:
  name: "user-management"
  path: "D:/projects/user-management"
  branch: "feature/user-management"
  base_branch: "main"
  git_platform: "github"

# AIé…ç½®
ai:
  primary_model: "claude"
  fallback_model: "deepseek"
  coding_prompt: "å¼€å‘ç”¨æˆ·ç®¡ç†åŠŸèƒ½ï¼ŒåŒ…æ‹¬ç”¨æˆ·å¢åˆ æ”¹æŸ¥"
  review_prompt: "æ ¹æ®å…¬å¸ç¼–ç è§„èŒƒå®¡æŸ¥ä»£ç "
  model: "claude-3-sonnet-20240229"
  max_tokens: 4000
  temperature: 0.1

# è¾“å‡ºé…ç½®
output:
  review_output: "./outputs/reviews"
  doc_output: "./outputs/docs"
  log_output: "./logs"

# é€šçŸ¥é…ç½®
notify:
  on_start: true
  on_complete: true
  on_error: true
  at_users: ["å¼ ä¸‰"]
```

##### éœ€æ±‚è¯„å®¡ä»»åŠ¡é…ç½® (tasks/requirement_review_task.yaml)
```yaml
task_id: "req_review_001"
name: "ç”¨æˆ·ç®¡ç†éœ€æ±‚è¯„å®¡"
type: "requirement_review"
priority: 2
enabled: true

# è°ƒåº¦é…ç½®
schedule:
  type: "cron"
  cron_expressions:
    - "0 10 * * 1"     # æ¯å‘¨ä¸€10ç‚¹æ‰§è¡Œ
    - "0 14 * * 3"     # æ¯å‘¨ä¸‰ä¸‹åˆ2ç‚¹æ‰§è¡Œ

# éœ€æ±‚æ–‡æ¡£é…ç½®
requirement:
  document_path: "./requirements/user-management-requirements.md"
  document_type: "markdown"  # markdown æˆ– word

# ä»£ç å‚è€ƒé…ç½®
code_reference:
  project_path: "D:/projects/user-management"
  branch: "main"
  package_paths:
    - "src/main/java/com/example/user"
    - "src/main/java/com/example/auth"
  analysis_depth: "full"  # full: æ¶æ„è®¾è®¡ã€æ¥å£å®šä¹‰ã€æ•°æ®æ¨¡å‹ç­‰

# AIé…ç½®
ai:
  primary_model: "claude"
  fallback_model: "deepseek"
  prompt_template: "è¯·åˆ†æéœ€æ±‚æ–‡æ¡£ä¸ä»£ç å®ç°çš„ä¸€è‡´æ€§ï¼Œé‡ç‚¹å…³æ³¨æ¶æ„è®¾è®¡ã€æ¥å£å®šä¹‰ã€æ•°æ®æ¨¡å‹ç­‰æ–¹é¢çš„åˆç†æ€§"

# è¾“å‡ºé…ç½®
output:
  review_output: "./outputs/requirement_reviews"
  format: "markdown"

# é€šçŸ¥é…ç½®
notify:
  on_start: true
  on_complete: true
  on_error: true
  at_users: ["äº§å“ç»ç†", "æ¶æ„å¸ˆ"]
```

##### è‡ªå®šä¹‰ä»»åŠ¡é…ç½® (tasks/custom_task.yaml)
```yaml
task_id: "custom_001"
name: "ä»£ç è´¨é‡åˆ†ææŠ¥å‘Š"
type: "custom"
priority: 3
enabled: true

# è°ƒåº¦é…ç½®
schedule:
  type: "cron"
  cron_expressions:
    - "0 20 * * 5"     # æ¯å‘¨äº”20ç‚¹æ‰§è¡Œ
    - "0 9 * * 1"      # æ¯å‘¨ä¸€ä¸Šåˆ9ç‚¹æ‰§è¡Œ

# è‡ªå®šä¹‰ä»»åŠ¡é…ç½®
custom:
  task_objective:
    description: "åˆ†æé¡¹ç›®ä»£ç è´¨é‡ï¼Œç”Ÿæˆç»¼åˆæŠ¥å‘Š"
    input_sources:
      - "D:/projects/user-management"
      - "./metrics/code_quality.json"

# AIé…ç½®
ai:
  primary_model: "claude"
  fallback_model: "deepseek"
  custom_prompt: "è¯·åˆ†æé¡¹ç›®ä»£ç è´¨é‡ï¼ŒåŒ…æ‹¬ä»£ç å¤æ‚åº¦ã€æµ‹è¯•è¦†ç›–ç‡ã€æŠ€æœ¯å€ºåŠ¡ç­‰æ–¹é¢ï¼Œç”Ÿæˆè¯¦ç»†çš„è¯„ä¼°æŠ¥å‘Š"

# è¾“å‡ºé…ç½®
output:
  format: "markdown"  # æ”¯æŒ markdown, excel, ppt
  output_path: "./outputs/custom_tasks"
  filename_template: "code_quality_report_{timestamp}"

# é€šçŸ¥é…ç½®
notify:
  on_start: true
  on_complete: true
  on_error: true
  at_users: ["æŠ€æœ¯è´Ÿè´£äºº"]

### 2.3 æ–°å¢é…ç½®é¡¹è¯¦ç»†è¯´æ˜

#### 2.3.1 ç¼–ç è§„èŒƒé…ç½®ï¼ˆæŒ‰è¯­è¨€åˆ†ç±»ï¼‰
```yaml
# åœ¨å…¨å±€é…ç½®ä¸­æ·»åŠ 
coding_standards:
  # Javaç¼–ç è§„èŒƒ
  java:
    file_path: "./standards/java_coding_standards.md"
    enabled: true
    description: "Javaç¼–ç è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"
    
  # Pythonç¼–ç è§„èŒƒ
  python:
    file_path: "./standards/python_coding_standards.md"
    enabled: true
    description: "Pythonç¼–ç è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"
    
  # å‰ç«¯ç¼–ç è§„èŒƒ
  frontend:
    file_path: "./standards/frontend_coding_standards.md"
    enabled: true
    description: "å‰ç«¯ç¼–ç è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"
    
  # é€šç”¨ç¼–ç è§„èŒƒ
  general:
    file_path: "./standards/general_coding_standards.md"
    enabled: true
    description: "é€šç”¨ç¼–ç è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"
    
  # çº¢çº¿è§„èŒƒ
  redlines:
    file_path: "./standards/redline_standards.md"
    enabled: true
    description: "ç¼–ç çº¢çº¿è§„èŒƒ"
    version: "1.0"
    last_updated: "2025-01-20"
```

**é…ç½®è¯´æ˜ï¼š**
- **file_path**: ç¼–ç è§„èŒƒæ–‡ä»¶çš„æœ¬åœ°è·¯å¾„ï¼Œæ”¯æŒç›¸å¯¹è·¯å¾„å’Œç»å¯¹è·¯å¾„
- **enabled**: æ˜¯å¦å¯ç”¨è¯¥è¯­è¨€çš„ç¼–ç è§„èŒƒæ£€æŸ¥
- **description**: ç¼–ç è§„èŒƒçš„æè¿°ä¿¡æ¯
- **version**: ç¼–ç è§„èŒƒç‰ˆæœ¬å·ï¼Œä¾¿äºç‰ˆæœ¬ç®¡ç†
- **last_updated**: æœ€åæ›´æ–°æ—¶é—´ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°è§„èŒƒ

#### 2.3.2 ä»»åŠ¡è¶…æ—¶æ—¶é—´é…ç½®
```yaml
# åœ¨å…¨å±€é…ç½®ä¸­æ·»åŠ 
task_timeouts:
  # ç¼–ç ä»»åŠ¡è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
  coding: 1800      # 30åˆ†é’Ÿï¼ˆä»£ç ç”Ÿæˆå¯èƒ½è¾ƒæ…¢ï¼‰
  review: 900       # 15åˆ†é’Ÿï¼ˆä»£ç å®¡æŸ¥ç›¸å¯¹è¾ƒå¿«ï¼‰
  doc: 600          # 10åˆ†é’Ÿï¼ˆæ–‡æ¡£ç”Ÿæˆè¾ƒå¿«ï¼‰
  requirement_review: 1200  # 20åˆ†é’Ÿï¼ˆéœ€æ±‚åˆ†æéœ€è¦æ—¶é—´ï¼‰
  custom: 1800      # 30åˆ†é’Ÿï¼ˆè‡ªå®šä¹‰ä»»åŠ¡å¯èƒ½å¤æ‚ï¼‰
  
  # å…¨å±€è¶…æ—¶é…ç½®
  global:
    default: 600    # é»˜è®¤è¶…æ—¶æ—¶é—´
    max: 7200       # æœ€å¤§è¶…æ—¶æ—¶é—´ï¼ˆ2å°æ—¶ï¼‰
    warning_threshold: 0.8  # è¶…æ—¶è­¦å‘Šé˜ˆå€¼ï¼ˆ80%æ—¶å‘å‡ºè­¦å‘Šï¼‰

# é‡è¯•é…ç½®
retry_config:
  max_attempts: 3           # æœ€å¤§é‡è¯•æ¬¡æ•°
  base_delay: 60            # åŸºç¡€é‡è¯•å»¶è¿Ÿï¼ˆç§’ï¼‰
  max_delay: 3600           # æœ€å¤§é‡è¯•å»¶è¿Ÿï¼ˆ1å°æ—¶ï¼‰
  backoff_multiplier: 2     # é€€é¿å€æ•°
  jitter: 0.1               # éšæœºæŠ–åŠ¨å› å­ï¼ˆé¿å…é›ªå´©ï¼‰
  
  # ä»»åŠ¡ç±»å‹ç‰¹å®šé‡è¯•é…ç½®
  task_specific:
    coding:
      max_attempts: 5       # ç¼–ç ä»»åŠ¡å…è®¸æ›´å¤šé‡è¯•
      base_delay: 120       # ç¼–ç ä»»åŠ¡åŸºç¡€å»¶è¿Ÿæ›´é•¿
    git_operations:
      max_attempts: 3       # Gitæ“ä½œé‡è¯•æ¬¡æ•°
      base_delay: 30        # Gitæ“ä½œå»¶è¿Ÿè¾ƒçŸ­
```

**é…ç½®è¯´æ˜ï¼š**
- **task_timeouts**: ä¸ºä¸åŒä»»åŠ¡ç±»å‹è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
- **retry_config**: é…ç½®æŒ‡æ•°é€€é¿é‡è¯•æœºåˆ¶ï¼Œé¿å…é¢‘ç¹é‡è¯•å¯¹ç³»ç»Ÿé€ æˆå‹åŠ›
- **jitter**: æ·»åŠ éšæœºæŠ–åŠ¨ï¼Œé¿å…å¤šä¸ªä»»åŠ¡åŒæ—¶é‡è¯•

#### 2.3.3 AIæ¨¡å‹é«˜çº§å‚æ•°é…ç½®
```yaml
# åœ¨å…¨å±€é…ç½®ä¸­æ‰©å±•AIæœåŠ¡é…ç½®
ai_services:
  claude:
    api_key: "${CLAUDE_API_KEY}"
    base_url: "https://api.anthropic.com"
    model: "claude-3-sonnet-20240229"
    
    # åŸºç¡€å‚æ•°
    max_tokens: 4000
    temperature: 0.1
    
    # é«˜çº§å‚æ•°
    parameters:
      temperature: 0.1              # åˆ›é€ æ€§ï¼ˆ0.0-1.0ï¼‰
      max_tokens: 4000              # æœ€å¤§è¾“å‡ºé•¿åº¦
      top_p: 0.9                    # æ ¸é‡‡æ ·å‚æ•°
      frequency_penalty: 0.0        # é¢‘ç‡æƒ©ç½š
      presence_penalty: 0.0         # å­˜åœ¨æƒ©ç½š
      stop_sequences: []            # åœæ­¢åºåˆ—
      
    # ä»»åŠ¡ç±»å‹ç‰¹å®šå‚æ•°
    task_parameters:
      coding:
        temperature: 0.05           # ç¼–ç ä»»åŠ¡éœ€è¦æ›´ç¡®å®šæ€§
        max_tokens: 6000            # ç¼–ç ä»»åŠ¡éœ€è¦æ›´å¤šè¾“å‡º
      review:
        temperature: 0.1            # å®¡æŸ¥ä»»åŠ¡ä¿æŒå¹³è¡¡
        max_tokens: 3000            # å®¡æŸ¥æ„è§ç›¸å¯¹è¾ƒçŸ­
      requirement_review:
        temperature: 0.15           # éœ€æ±‚è¯„å®¡éœ€è¦ä¸€å®šåˆ›é€ æ€§
        max_tokens: 5000            # è¯„å®¡æŠ¥å‘Šéœ€è¦è¯¦ç»†åˆ†æ
  
  deepseek:
    api_key: "${DEEPSEEK_API_KEY}"
    base_url: "https://api.deepseek.com"
    model: "deepseek-coder"
    
    # åŸºç¡€å‚æ•°
    max_tokens: 4000
    temperature: 0.1
    
    # é«˜çº§å‚æ•°
    parameters:
      temperature: 0.1              # åˆ›é€ æ€§
      max_tokens: 4000              # æœ€å¤§è¾“å‡ºé•¿åº¦
      top_p: 0.9                    # æ ¸é‡‡æ ·å‚æ•°
      repetition_penalty: 1.0       # é‡å¤æƒ©ç½š
      top_k: 40                     # Top-Ké‡‡æ ·
      
    # ä»»åŠ¡ç±»å‹ç‰¹å®šå‚æ•°
    task_parameters:
      coding:
        temperature: 0.05
        max_tokens: 6000
      review:
        temperature: 0.1
        max_tokens: 3000
      requirement_review:
        temperature: 0.15
        max_tokens: 5000
```

**é…ç½®è¯´æ˜ï¼š**
- **parameters**: æ¨¡å‹çš„åŸºç¡€å‚æ•°é…ç½®ï¼Œå½±å“AIè¾“å‡ºçš„è´¨é‡å’Œé£æ ¼
- **task_parameters**: ä¸ºä¸åŒä»»åŠ¡ç±»å‹ä¼˜åŒ–å‚æ•°ï¼Œæé«˜ä»»åŠ¡æ‰§è¡Œæ•ˆæœ
- **temperature**: æ§åˆ¶è¾“å‡ºçš„éšæœºæ€§ï¼Œç¼–ç ä»»åŠ¡éœ€è¦ä½æ¸©åº¦ç¡®ä¿ä»£ç è´¨é‡
- **max_tokens**: æ§åˆ¶è¾“å‡ºé•¿åº¦ï¼Œæ ¹æ®ä»»åŠ¡å¤æ‚åº¦è°ƒæ•´

#### 2.3.4 çŠ¶æ€æ–‡ä»¶ç®¡ç†é…ç½®ï¼ˆå‡Œæ™¨2ç‚¹æ¸…ç†ï¼‰
```yaml
# åœ¨å…¨å±€é…ç½®ä¸­æ·»åŠ 
state_management:
  # æ¸…ç†é…ç½®
  cleanup_enabled: true            # å¯ç”¨çŠ¶æ€æ–‡ä»¶æ¸…ç†
  retention_days: 90               # çŠ¶æ€æ–‡ä»¶ä¿ç•™90å¤©
  archive_enabled: true            # å¯ç”¨å½’æ¡£åŠŸèƒ½
  archive_path: "./archives/states"  # å½’æ¡£æ–‡ä»¶è·¯å¾„
  
  # æ¸…ç†è°ƒåº¦
  cleanup_schedule: "0 2 * * *"    # æ¯å¤©å‡Œæ™¨2ç‚¹æ¸…ç†ï¼ˆcrontabæ ¼å¼ï¼‰
  
  # æ¸…ç†ç­–ç•¥
  cleanup_strategy:
    completed_tasks: "archive"      # å·²å®Œæˆä»»åŠ¡ï¼šå½’æ¡£
    failed_tasks: "archive"         # å¤±è´¥ä»»åŠ¡ï¼šå½’æ¡£
    running_tasks: "skip"           # è¿è¡Œä¸­ä»»åŠ¡ï¼šè·³è¿‡
    expired_tasks: "delete"         # è¿‡æœŸä»»åŠ¡ï¼šåˆ é™¤
    
  # å½’æ¡£é…ç½®
  archive:
    compression: true               # å¯ç”¨å‹ç¼©
    compression_format: "zip"       # å‹ç¼©æ ¼å¼
    max_archive_size: "100MB"      # æœ€å¤§å½’æ¡£æ–‡ä»¶å¤§å°
    archive_retention_days: 365    # å½’æ¡£æ–‡ä»¶ä¿ç•™1å¹´
    
  # çŠ¶æ€æ–‡ä»¶é…ç½®
  state_file:
    max_size: "10MB"               # å•ä¸ªçŠ¶æ€æ–‡ä»¶æœ€å¤§å¤§å°
    backup_enabled: true           # å¯ç”¨å¤‡ä»½
    backup_count: 3                # ä¿ç•™å¤‡ä»½æ•°é‡
    backup_interval: "1h"          # å¤‡ä»½é—´éš”
```

**é…ç½®è¯´æ˜ï¼š**
- **cleanup_schedule**: ä½¿ç”¨crontabè¡¨è¾¾å¼è®¾ç½®æ¸…ç†æ—¶é—´ï¼Œå‡Œæ™¨2ç‚¹æ‰§è¡Œé¿å…å½±å“æ­£å¸¸ä»»åŠ¡
- **cleanup_strategy**: é’ˆå¯¹ä¸åŒçŠ¶æ€çš„ä»»åŠ¡é‡‡ç”¨ä¸åŒçš„æ¸…ç†ç­–ç•¥
- **archive**: é‡è¦çŠ¶æ€ä¿¡æ¯è¿›è¡Œå½’æ¡£ä¿å­˜ï¼Œä¾¿äºåç»­åˆ†æå’Œå®¡è®¡

#### 2.3.5 é€šçŸ¥æ¨¡æ¿é…ç½®ï¼ˆæ”¯æŒä»»åŠ¡ç±»å‹ä¸ªæ€§åŒ–ï¼‰
```yaml
# åœ¨å…¨å±€é…ç½®ä¸­æ·»åŠ 
notification_templates:
  # é€šç”¨æ¨¡æ¿å˜é‡
  variables:
    task_name: "{task_name}"           # ä»»åŠ¡åç§°
    task_type: "{task_type}"           # ä»»åŠ¡ç±»å‹
    task_id: "{task_id}"               # ä»»åŠ¡ID
    duration: "{duration}"             # æ‰§è¡Œæ—¶é•¿
    error_message: "{error_message}"   # é”™è¯¯ä¿¡æ¯
    files_count: "{files_count}"       # ç”Ÿæˆæ–‡ä»¶æ•°é‡
    issues_count: "{issues_count}"     # å‘ç°é—®é¢˜æ•°é‡
    inconsistencies_count: "{inconsistencies_count}"  # ä¸ä¸€è‡´ç‚¹æ•°é‡
    
  # é€šç”¨æ¨¡æ¿
  common:
    task_start: "ğŸš€ ä»»åŠ¡ {task_name} ({task_type}) å¼€å§‹æ‰§è¡Œ"
    task_complete: "âœ… ä»»åŠ¡ {task_name} æ‰§è¡Œå®Œæˆï¼Œè€—æ—¶ {duration}"
    task_error: "âŒ ä»»åŠ¡ {task_name} æ‰§è¡Œå¤±è´¥: {error_message}"
    
  # ä»»åŠ¡ç±»å‹ç‰¹å®šæ¨¡æ¿
  task_specific:
    coding:
      start: "ğŸ”§ ç¼–ç ä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… ç¼–ç ä»»åŠ¡ {task_name} å®Œæˆï¼Œç”Ÿæˆäº† {files_count} ä¸ªæ–‡ä»¶"
      error: "âŒ ç¼–ç ä»»åŠ¡ {task_name} å¤±è´¥: {error_message}"
      review_required: "ğŸ” ç¼–ç ä»»åŠ¡ {task_name} å®Œæˆï¼Œç­‰å¾…ä»£ç å®¡æŸ¥"
      
    review:
      start: "ğŸ” ä»£ç å®¡æŸ¥ä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… ä»£ç å®¡æŸ¥å®Œæˆï¼Œå‘ç° {issues_count} ä¸ªé—®é¢˜"
      error: "âŒ ä»£ç å®¡æŸ¥å¤±è´¥: {error_message}"
      issues_found: "âš ï¸ ä»£ç å®¡æŸ¥å‘ç° {issues_count} ä¸ªé—®é¢˜ï¼Œéœ€è¦é‡æ–°ç¼–ç "
      no_issues: "âœ… ä»£ç å®¡æŸ¥é€šè¿‡ï¼Œä»»åŠ¡å®Œæˆ"
      
    doc:
      start: "ğŸ“š æ–‡æ¡£ç”Ÿæˆä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… æ–‡æ¡£ç”Ÿæˆå®Œæˆï¼Œè¾“å‡ºåˆ° {output_path}"
      error: "âŒ æ–‡æ¡£ç”Ÿæˆå¤±è´¥: {error_message}"
      
    requirement_review:
      start: "ğŸ“‹ éœ€æ±‚è¯„å®¡ä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… éœ€æ±‚è¯„å®¡å®Œæˆï¼Œå‘ç° {inconsistencies_count} ä¸ªä¸ä¸€è‡´ç‚¹"
      error: "âŒ éœ€æ±‚è¯„å®¡å¤±è´¥: {error_message}"
      critical_issues: "ğŸš¨ éœ€æ±‚è¯„å®¡å‘ç°å…³é”®é—®é¢˜ï¼Œè¯·åŠæ—¶å¤„ç†"
      
    custom:
      start: "âš™ï¸ è‡ªå®šä¹‰ä»»åŠ¡ {task_name} å¼€å§‹æ‰§è¡Œ"
      complete: "âœ… è‡ªå®šä¹‰ä»»åŠ¡ {task_name} æ‰§è¡Œå®Œæˆ"
      error: "âŒ è‡ªå®šä¹‰ä»»åŠ¡ {task_name} æ‰§è¡Œå¤±è´¥: {error_message}"
  
  # é€šçŸ¥çº§åˆ«é…ç½®
  notification_levels:
    info: ["task_start", "task_complete"]           # ä¿¡æ¯çº§åˆ«é€šçŸ¥
    warning: ["review_required", "issues_found"]    # è­¦å‘Šçº§åˆ«é€šçŸ¥
    error: ["task_error", "critical_issues"]        # é”™è¯¯çº§åˆ«é€šçŸ¥
    
  # é€šçŸ¥æ¸ é“é…ç½®
  channels:
    dingtalk:
      enabled: true
      webhook_url: "${DINGTALK_WEBHOOK}"
      secret: "${DINGTALK_SECRET}"
      at_users: ["å¼ ä¸‰", "æå››"]
      at_all: false                                 # æ˜¯å¦@æ‰€æœ‰äºº
      
    email:
      enabled: false                                # é‚®ä»¶é€šçŸ¥ï¼ˆé¢„ç•™ï¼‰
      smtp_server: ""
      smtp_port: 587
      username: ""
      password: ""
      
    webhook:
      enabled: false                                # é€šç”¨Webhookï¼ˆé¢„ç•™ï¼‰
      url: ""
      headers: {}
```

**é…ç½®è¯´æ˜ï¼š**
- **variables**: å®šä¹‰æ¨¡æ¿ä¸­å¯ç”¨çš„å˜é‡ï¼Œæ”¯æŒåŠ¨æ€å†…å®¹æ›¿æ¢
- **task_specific**: ä¸ºä¸åŒä»»åŠ¡ç±»å‹æä¾›ä¸ªæ€§åŒ–çš„é€šçŸ¥æ¨¡æ¿ï¼Œæé«˜é€šçŸ¥çš„é’ˆå¯¹æ€§å’Œå¯è¯»æ€§
- **notification_levels**: æ ¹æ®é€šçŸ¥å†…å®¹çš„é‡è¦æ€§åˆ†ç±»ï¼Œä¾¿äºç”¨æˆ·é…ç½®ä¸åŒçº§åˆ«çš„é€šçŸ¥ç­–ç•¥
- **channels**: æ”¯æŒå¤šç§é€šçŸ¥æ¸ é“ï¼Œå½“å‰ä¸»è¦ä½¿ç”¨é’‰é’‰æœºå™¨äººï¼Œé¢„ç•™å…¶ä»–æ¸ é“æ‰©å±•

#### 2.3.6 ç¼–ç è§„èŒƒæ–‡ä»¶ç¤ºä¾‹ç»“æ„
```yaml
# ç¼–ç è§„èŒƒæ–‡ä»¶ç¤ºä¾‹ (standards/java_coding_standards.md)
# æ–‡ä»¶è·¯å¾„: ./standards/java_coding_standards.md

---
title: "Javaç¼–ç è§„èŒƒ v1.0"
version: "1.0"
last_updated: "2025-01-20"
language: "java"
framework: "spring-boot"
---

## å‘½åè§„èŒƒ
- ç±»åï¼šä½¿ç”¨PascalCaseï¼Œå¦‚ `UserService`
- æ–¹æ³•åï¼šä½¿ç”¨camelCaseï¼Œå¦‚ `getUserById`
- å¸¸é‡ï¼šä½¿ç”¨UPPER_SNAKE_CASEï¼Œå¦‚ `MAX_RETRY_COUNT`
- åŒ…åï¼šä½¿ç”¨å°å†™å­—æ¯ï¼Œå¦‚ `com.example.user`

## ä»£ç ç»“æ„
- ç±»æˆå‘˜é¡ºåºï¼šé™æ€å¸¸é‡ã€å®ä¾‹å˜é‡ã€æ„é€ æ–¹æ³•ã€å…¬å…±æ–¹æ³•ã€ç§æœ‰æ–¹æ³•
- æ–¹æ³•é•¿åº¦ï¼šå•ä¸ªæ–¹æ³•ä¸è¶…è¿‡50è¡Œ
- ç±»é•¿åº¦ï¼šå•ä¸ªç±»ä¸è¶…è¿‡500è¡Œ

## å¼‚å¸¸å¤„ç†
- ä½¿ç”¨å…·ä½“çš„å¼‚å¸¸ç±»å‹ï¼Œé¿å…æ•è·é€šç”¨Exception
- è®°å½•è¯¦ç»†çš„é”™è¯¯æ—¥å¿—ï¼ŒåŒ…å«ä¸Šä¸‹æ–‡ä¿¡æ¯
- å¯¹å¤–æ¥å£è¿”å›ç»Ÿä¸€çš„é”™è¯¯å“åº”æ ¼å¼

## æ€§èƒ½è§„èŒƒ
- é¿å…åœ¨å¾ªç¯ä¸­è¿›è¡Œæ•°æ®åº“æŸ¥è¯¢
- ä½¿ç”¨StringBuilderè¿›è¡Œå­—ç¬¦ä¸²æ‹¼æ¥
- åˆç†ä½¿ç”¨ç¼“å­˜æœºåˆ¶

## çº¢çº¿è§„èŒƒ
- ç¦æ­¢ä½¿ç”¨System.out.println()è¾“å‡ºæ—¥å¿—
- ç¦æ­¢åœ¨finallyå—ä¸­return
- ç¦æ­¢ä½¿ç”¨Thread.sleep()è¿›è¡Œä¸šåŠ¡é€»è¾‘æ§åˆ¶
```

**é…ç½®è¯´æ˜ï¼š**
- ç¼–ç è§„èŒƒæ–‡ä»¶ä½¿ç”¨Markdownæ ¼å¼ï¼Œä¾¿äºé˜…è¯»å’Œç»´æŠ¤
- æ”¯æŒç‰ˆæœ¬ç®¡ç†å’Œæ›´æ–°è®°å½•
- åŒ…å«å…·ä½“çš„ç¼–ç æ ‡å‡†å’Œçº¢çº¿è§„èŒƒ
- å¯æ ¹æ®é¡¹ç›®éœ€è¦è¿›è¡Œå®šåˆ¶åŒ–è°ƒæ•´
```

### 2.3 çŠ¶æ€æ–‡ä»¶ç»“æ„

#### ä»»åŠ¡çŠ¶æ€æ–‡ä»¶ (states/task_001.json)
```json
{
  "task_id": "task_001",
  "task_name": "ç”¨æˆ·ç®¡ç†åŠŸèƒ½å¼€å‘",
  "task_type": "coding",
  "current_state": "coding",
  "status": "running",
  "current_round": 1,
  "max_rounds": 5,
  "start_time": "2025-01-20T09:00:00Z",
  "last_update": "2025-01-20T09:30:00Z",
  
  "coding_state": {
    "status": "completed",
    "start_time": "2025-01-20T09:00:00Z",
    "end_time": "2025-01-20T09:30:00Z",
    "commit_hash": "abc123",
    "files_changed": ["src/UserService.java", "src/UserController.java"]
  },
  
  "review_state": {
    "status": "pending",
    "start_time": null,
    "end_time": null,
    "review_opinions": [],
    "issues_found": 0
  },
  
  "history": [
    {
      "round": 1,
      "state": "coding",
      "timestamp": "2025-01-20T09:00:00Z",
      "details": "å¼€å§‹ç¼–ç ä»»åŠ¡"
    }
  ]
}
```

## 3. æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 3.1 ä»»åŠ¡è°ƒåº¦å™¨ (Scheduler)
```python
class TaskScheduler:
    """ä»»åŠ¡è°ƒåº¦å™¨ï¼ŒåŸºäºAPSchedulerå®ç°"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.scheduler = APScheduler()
        self.running_tasks = {}
    
    def start(self):
        """å¯åŠ¨è°ƒåº¦å™¨"""
        self.scheduler.start()
        self._load_tasks()
    
    def _load_tasks(self):
        """åŠ è½½æ‰€æœ‰ä»»åŠ¡é…ç½®"""
        tasks = self.config_manager.get_all_tasks()
        for task in tasks:
            if task.enabled:
                self._schedule_task(task)
    
    def _schedule_task(self, task):
        """è°ƒåº¦å•ä¸ªä»»åŠ¡"""
        for cron_expr in task.schedule.cron_expressions:
            self.scheduler.add_job(
                func=self._execute_task,
                trigger='cron',
                args=[task.task_id],
                **self._parse_cron(cron_expr)
            )
    
    def _execute_task(self, task_id):
        """æ‰§è¡Œä»»åŠ¡"""
        if self._can_execute_task(task_id):
            executor = TaskExecutor(task_id, self.config_manager)
            executor.start()
```

### 3.2 ä»»åŠ¡æ‰§è¡Œå™¨ (Executor)
```python
class TaskExecutor:
    """ä»»åŠ¡æ‰§è¡Œå™¨ï¼Œç®¡ç†ä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸ"""
    
    def __init__(self, task_id, config_manager):
        self.task_id = task_id
        self.config_manager = config_manager
        self.task_config = config_manager.get_task_config(task_id)
        self.state_manager = StateManager(task_id)
        self.ai_service = AIService()
        self.git_service = GitService()
        self.notify_service = NotifyService()
    
    def start(self):
        """å¼€å§‹æ‰§è¡Œä»»åŠ¡"""
        try:
            self.notify_service.notify_task_start(self.task_config)
            self._execute_task_logic()
        except Exception as e:
            self._handle_error(e)
    
    def _execute_task_logic(self):
        """æ‰§è¡Œä»»åŠ¡é€»è¾‘"""
        try:
            # è·å–ä»»åŠ¡è¶…æ—¶é…ç½®
            timeout = self.config_manager.get_task_timeout(self.task_config.type)
            
            # è®¾ç½®ä»»åŠ¡è¶…æ—¶
            with timeout_context(timeout):
                if self.task_config.type == "coding":
                    self._execute_coding_task()
                elif self.task_config.type == "review":
                    self._execute_review_task()
                elif self.task_config.type == "doc":
                    self._execute_doc_task()
                elif self.task_config.type == "requirement_review":
                    self._execute_requirement_review_task()
                elif self.task_config.type == "custom":
                    self._execute_custom_task()
                    
        except TimeoutError:
            self._handle_timeout()
        except Exception as e:
            self._handle_error(e)
    
    def _handle_timeout(self):
        """å¤„ç†ä»»åŠ¡è¶…æ—¶"""
        logger.warning(f"ä»»åŠ¡ {self.task_id} æ‰§è¡Œè¶…æ—¶")
        self.notify_service.notify_task_timeout(self.task_config)
        
        # æ ¹æ®é…ç½®å†³å®šæ˜¯å¦é‡è¯•
        retry_config = self.config_manager.get_retry_config(self.task_config.type)
        if self._should_retry(retry_config):
            self._schedule_retry(retry_config)
    
    def _should_retry(self, retry_config):
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•"""
        # å®ç°é‡è¯•åˆ¤æ–­é€»è¾‘
        pass
    
    def _schedule_retry(self, retry_config):
        """è°ƒåº¦é‡è¯•ä»»åŠ¡"""
        # å®ç°é‡è¯•è°ƒåº¦é€»è¾‘
        pass
    
    def _execute_coding_task(self):
        """æ‰§è¡Œç¼–ç ä»»åŠ¡"""
        coding_task = CodingTask(self.task_config, self.ai_service, self.git_service)
        coding_task.execute()
    
    def _execute_requirement_review_task(self):
        """æ‰§è¡Œéœ€æ±‚è¯„å®¡ä»»åŠ¡"""
        requirement_review_task = RequirementReviewTask(self.task_config, self.ai_service, self.git_service)
        requirement_review_task.execute()
    
    def _execute_custom_task(self):
        """æ‰§è¡Œè‡ªå®šä¹‰ä»»åŠ¡"""
        custom_task = CustomTask(self.task_config, self.ai_service, self.git_service)
        custom_task.execute()
```

### 3.3 çŠ¶æ€åè°ƒå™¨ (StateManager)
```python
class StateManager:
    """çŠ¶æ€åè°ƒå™¨ï¼Œç®¡ç†ä»»åŠ¡çŠ¶æ€è½¬æ¢"""
    
    def __init__(self, task_id):
        self.task_id = task_id
        self.state_file = f"states/{task_id}.json"
        self.lock = threading.Lock()
    
    def get_current_state(self):
        """è·å–å½“å‰çŠ¶æ€"""
        with self.lock:
            if os.path.exists(self.state_file):
                with open(self.state_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            return self._create_initial_state()
    
    def update_state(self, new_state, details=None):
        """æ›´æ–°çŠ¶æ€"""
        with self.lock:
            current_state = self.get_current_state()
            current_state.update(new_state)
            current_state['last_update'] = datetime.utcnow().isoformat()
            
            if details:
                current_state['history'].append({
                    'round': current_state.get('current_round', 1),
                    'state': new_state.get('current_state'),
                    'timestamp': datetime.utcnow().isoformat(),
                    'details': details
                })
            
            self._save_state(current_state)
    
    def transition_to_state(self, target_state):
        """çŠ¶æ€è½¬æ¢"""
        current_state = self.get_current_state()
        if target_state == "reviewing" and current_state['current_state'] == "coding":
            self.update_state({
                'current_state': 'reviewing',
                'coding_state': {'status': 'completed', 'end_time': datetime.utcnow().isoformat()}
            })
        elif target_state == "coding" and current_state['current_state'] == "reviewing":
            self.update_state({
                'current_state': 'coding',
                'current_round': current_state.get('current_round', 1) + 1,
                'review_state': {'status': 'completed', 'end_time': datetime.utcnow().isoformat()}
            })
    
    def cleanup_expired_states(self):
        """æ¸…ç†è¿‡æœŸçš„çŠ¶æ€æ–‡ä»¶"""
        # å®ç°çŠ¶æ€æ–‡ä»¶æ¸…ç†é€»è¾‘
        pass

### 3.4 é…ç½®ç®¡ç†å™¨ (ConfigManager)
```python
class ConfigManager:
    """é…ç½®ç®¡ç†å™¨ï¼Œç®¡ç†å…¨å±€å’Œä»»åŠ¡çº§é…ç½®"""
    
    def __init__(self, config_dir="./config"):
        self.config_dir = config_dir
        self.global_config = None
        self.task_configs = {}
        self.coding_standards = {}
        self._load_configs()
    
    def _load_configs(self):
        """åŠ è½½æ‰€æœ‰é…ç½®æ–‡ä»¶"""
        self._load_global_config()
        self._load_task_configs()
        self._load_coding_standards()
    
    def _load_global_config(self):
        """åŠ è½½å…¨å±€é…ç½®"""
        global_config_path = os.path.join(self.config_dir, "global_config.yaml")
        if os.path.exists(global_config_path):
            with open(global_config_path, 'r', encoding='utf-8') as f:
                self.global_config = yaml.safe_load(f)
        else:
            self.global_config = self._get_default_global_config()
    
    def _load_coding_standards(self):
        """åŠ è½½ç¼–ç è§„èŒƒæ–‡ä»¶"""
        if not self.global_config or 'coding_standards' not in self.global_config:
            return
        
        for lang, config in self.global_config['coding_standards'].items():
            if config.get('enabled', False):
                file_path = config['file_path']
                if os.path.exists(file_path):
                    with open(file_path, 'r', encoding='utf-8') as f:
                        self.coding_standards[lang] = {
                            'content': f.read(),
                            'config': config
                        }
    
    def get_coding_standards(self, language=None):
        """è·å–ç¼–ç è§„èŒƒ"""
        if language:
            return self.coding_standards.get(language)
        return self.coding_standards
    
    def get_task_timeout(self, task_type):
        """è·å–ä»»åŠ¡è¶…æ—¶æ—¶é—´"""
        if not self.global_config or 'task_timeouts' not in self.global_config:
            return 600  # é»˜è®¤10åˆ†é’Ÿ
        
        timeouts = self.global_config['task_timeouts']
        return timeouts.get(task_type, timeouts.get('global', {}).get('default', 600))
    
    def get_retry_config(self, task_type=None):
        """è·å–é‡è¯•é…ç½®"""
        if not self.global_config or 'retry_config' not in self.global_config:
            return self._get_default_retry_config()
        
        retry_config = self.global_config['retry_config']
        if task_type and 'task_specific' in retry_config:
            task_retry = retry_config['task_specific'].get(task_type, {})
            # åˆå¹¶å…¨å±€é…ç½®å’Œä»»åŠ¡ç‰¹å®šé…ç½®
            return {**retry_config, **task_retry}
        
        return retry_config
    
    def get_ai_parameters(self, model, task_type):
        """è·å–AIæ¨¡å‹å‚æ•°"""
        if not self.global_config or 'ai_services' not in self.global_config:
            return {}
        
        ai_config = self.global_config['ai_services'].get(model, {})
        if 'task_parameters' in ai_config and task_type in ai_config['task_parameters']:
            return ai_config['task_parameters'][task_type]
        
        return ai_config.get('parameters', {})
    
    def get_notification_template(self, task_type, event_type):
        """è·å–é€šçŸ¥æ¨¡æ¿"""
        if not self.global_config or 'notification_templates' not in self.global_config:
            return self._get_default_notification_template()
        
        templates = self.global_config['notification_templates']
        
        # ä¼˜å…ˆä½¿ç”¨ä»»åŠ¡ç±»å‹ç‰¹å®šæ¨¡æ¿
        if 'task_specific' in templates and task_type in templates['task_specific']:
            task_templates = templates['task_specific'][task_type]
            if event_type in task_templates:
                return task_templates[event_type]
        
        # å›é€€åˆ°é€šç”¨æ¨¡æ¿
        if 'common' in templates and event_type in templates['common']:
            return templates['common'][event_type]
        
        return self._get_default_notification_template()
    
    def _get_default_global_config(self):
        """è·å–é»˜è®¤å…¨å±€é…ç½®"""
        return {
            'task_timeouts': {
                'coding': 1800,
                'review': 900,
                'doc': 600,
                'requirement_review': 1200,
                'custom': 1800,
                'global': {'default': 600, 'max': 7200}
            },
            'retry_config': {
                'max_attempts': 3,
                'base_delay': 60,
                'max_delay': 3600,
                'backoff_multiplier': 2,
                'jitter': 0.1
            }
        }
    
    def _get_default_retry_config(self):
        """è·å–é»˜è®¤é‡è¯•é…ç½®"""
        return {
            'max_attempts': 3,
            'base_delay': 60,
            'max_delay': 3600,
            'backoff_multiplier': 2,
            'jitter': 0.1
        }
    
    def _get_default_notification_template(self):
        """è·å–é»˜è®¤é€šçŸ¥æ¨¡æ¿"""
        return "ä»»åŠ¡ {task_name} æ‰§è¡Œ{event_type}"

### 3.5 çŠ¶æ€æ–‡ä»¶ç®¡ç†å™¨ (StateFileManager)
```python
class StateFileManager:
    """çŠ¶æ€æ–‡ä»¶ç®¡ç†å™¨ï¼Œè´Ÿè´£çŠ¶æ€æ–‡ä»¶çš„æ¸…ç†ã€å½’æ¡£å’Œå¤‡ä»½"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.config = config_manager.global_config.get('state_management', {})
        self.states_dir = "./states"
        self.archives_dir = self.config.get('archive_path', './archives/states')
        self.cleanup_scheduler = None
    
    def start_cleanup_scheduler(self):
        """å¯åŠ¨æ¸…ç†è°ƒåº¦å™¨"""
        if not self.config.get('cleanup_enabled', False):
            return
        
        cleanup_schedule = self.config.get('cleanup_schedule', '0 2 * * *')
        self.cleanup_scheduler = APScheduler()
        self.cleanup_scheduler.add_job(
            func=self.cleanup_expired_states,
            trigger='cron',
            **self._parse_cron(cleanup_schedule)
        )
        self.cleanup_scheduler.start()
    
    def cleanup_expired_states(self):
        """æ¸…ç†è¿‡æœŸçš„çŠ¶æ€æ–‡ä»¶"""
        try:
            retention_days = self.config.get('retention_days', 90)
            cutoff_date = datetime.now() - timedelta(days=retention_days)
            
            for filename in os.listdir(self.states_dir):
                if filename.endswith('.json'):
                    file_path = os.path.join(self.states_dir, filename)
                    file_mtime = datetime.fromtimestamp(os.path.getmtime(file_path))
                    
                    if file_mtime < cutoff_date:
                        self._process_expired_state(file_path, filename)
                        
        except Exception as e:
            logger.error(f"æ¸…ç†çŠ¶æ€æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {e}")
    
    def _process_expired_state(self, file_path, filename):
        """å¤„ç†è¿‡æœŸçš„çŠ¶æ€æ–‡ä»¶"""
        cleanup_strategy = self.config.get('cleanup_strategy', {})
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                state_data = json.load(f)
            
            task_status = state_data.get('status', 'unknown')
            
            if cleanup_strategy.get('completed_tasks') == 'archive':
                if task_status in ['completed', 'failed']:
                    self._archive_state_file(file_path, filename, state_data)
                    os.remove(file_path)
                    logger.info(f"å·²å½’æ¡£å®Œæˆçš„ä»»åŠ¡çŠ¶æ€æ–‡ä»¶: {filename}")
                    return
            
            if cleanup_strategy.get('expired_tasks') == 'delete':
                os.remove(file_path)
                logger.info(f"å·²åˆ é™¤è¿‡æœŸçš„çŠ¶æ€æ–‡ä»¶: {filename}")
                
        except Exception as e:
            logger.error(f"å¤„ç†è¿‡æœŸçŠ¶æ€æ–‡ä»¶ {filename} æ—¶å‘ç”Ÿé”™è¯¯: {e}")
    
    def _archive_state_file(self, file_path, filename, state_data):
        """å½’æ¡£çŠ¶æ€æ–‡ä»¶"""
        if not self.config.get('archive_enabled', False):
            return
        
        try:
            # åˆ›å»ºå½’æ¡£ç›®å½•
            os.makedirs(self.archives_dir, exist_ok=True)
            
            # ç”Ÿæˆå½’æ¡£æ–‡ä»¶å
            archive_date = datetime.now().strftime('%Y%m%d')
            archive_filename = f"{archive_date}_{filename}"
            archive_path = os.path.join(self.archives_dir, archive_filename)
            
            # å¤åˆ¶æ–‡ä»¶åˆ°å½’æ¡£ç›®å½•
            shutil.copy2(file_path, archive_path)
            
            # å¦‚æœå¯ç”¨å‹ç¼©ï¼Œè¿›è¡Œå‹ç¼©
            if self.config.get('archive', {}).get('compression', False):
                self._compress_archive(archive_path)
                
            logger.info(f"çŠ¶æ€æ–‡ä»¶å·²å½’æ¡£: {filename} -> {archive_path}")
            
        except Exception as e:
            logger.error(f"å½’æ¡£çŠ¶æ€æ–‡ä»¶ {filename} æ—¶å‘ç”Ÿé”™è¯¯: {e}")
    
    def _compress_archive(self, archive_path):
        """å‹ç¼©å½’æ¡£æ–‡ä»¶"""
        try:
            compression_format = self.config.get('archive', {}).get('compression_format', 'zip')
            if compression_format == 'zip':
                import zipfile
                zip_path = archive_path + '.zip'
                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    zipf.write(archive_path, os.path.basename(archive_path))
                os.remove(archive_path)  # åˆ é™¤åŸæ–‡ä»¶
                logger.info(f"å½’æ¡£æ–‡ä»¶å·²å‹ç¼©: {archive_path} -> {zip_path}")
                
        except Exception as e:
            logger.error(f"å‹ç¼©å½’æ¡£æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {e}")
    
    def backup_state_files(self):
        """å¤‡ä»½çŠ¶æ€æ–‡ä»¶"""
        if not self.config.get('state_file', {}).get('backup_enabled', False):
            return
        
        try:
            backup_count = self.config.get('state_file', {}).get('backup_count', 3)
            backup_interval = self.config.get('state_file', {}).get('backup_interval', '1h')
            
            # å®ç°å¤‡ä»½é€»è¾‘
            # ...
            
        except Exception as e:
            logger.error(f"å¤‡ä»½çŠ¶æ€æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {e}")
    
    def _parse_cron(self, cron_expr):
        """è§£æcrontabè¡¨è¾¾å¼"""
        # å®ç°crontabè§£æé€»è¾‘
        # è¿”å›APScheduleræ”¯æŒçš„å‚æ•°
        pass

### 3.6 é€šçŸ¥æœåŠ¡ (NotifyService)
```python
class NotifyService:
    """é€šçŸ¥æœåŠ¡ï¼Œæ”¯æŒå¤šç§é€šçŸ¥æ¸ é“å’Œä¸ªæ€§åŒ–æ¨¡æ¿"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.config = config_manager.global_config.get('notification_templates', {})
        self.channels = self._init_channels()
    
    def _init_channels(self):
        """åˆå§‹åŒ–é€šçŸ¥æ¸ é“"""
        channels = {}
        channels_config = self.config.get('channels', {})
        
        if channels_config.get('dingtalk', {}).get('enabled', False):
            channels['dingtalk'] = DingTalkNotifier(channels_config['dingtalk'])
        
        if channels_config.get('email', {}).get('enabled', False):
            channels['email'] = EmailNotifier(channels_config['email'])
        
        if channels_config.get('webhook', {}).get('enabled', False):
            channels['webhook'] = WebhookNotifier(channels_config['webhook'])
        
        return channels
    
    def notify_task_start(self, task_config):
        """é€šçŸ¥ä»»åŠ¡å¼€å§‹"""
        self._notify_task_event(task_config, 'start')
    
    def notify_task_complete(self, task_config, duration=None, result_info=None):
        """é€šçŸ¥ä»»åŠ¡å®Œæˆ"""
        self._notify_task_event(task_config, 'complete', duration, result_info)
    
    def notify_task_error(self, task_config, error_message):
        """é€šçŸ¥ä»»åŠ¡é”™è¯¯"""
        self._notify_task_event(task_config, 'error', error_message=error_message)
    
    def notify_task_timeout(self, task_config):
        """é€šçŸ¥ä»»åŠ¡è¶…æ—¶"""
        self._notify_task_event(task_config, 'timeout')
    
    def notify_review_required(self, task_config):
        """é€šçŸ¥éœ€è¦ä»£ç å®¡æŸ¥"""
        self._notify_task_event(task_config, 'review_required')
    
    def notify_issues_found(self, task_config, issues_count):
        """é€šçŸ¥å‘ç°é—®é¢˜"""
        self._notify_task_event(task_config, 'issues_found', issues_count=issues_count)
    
    def notify_critical_issues(self, task_config, issues_description):
        """é€šçŸ¥å…³é”®é—®é¢˜"""
        self._notify_task_event(task_config, 'critical_issues', issues_description=issues_description)
    
    def _notify_task_event(self, task_config, event_type, *args, **kwargs):
        """é€šçŸ¥ä»»åŠ¡äº‹ä»¶"""
        try:
            # è·å–é€šçŸ¥æ¨¡æ¿
            template = self.config_manager.get_notification_template(
                task_config.type, event_type
            )
            
            # å‡†å¤‡æ¨¡æ¿å˜é‡
            variables = self._prepare_template_variables(
                task_config, event_type, *args, **kwargs
            )
            
            # æ¸²æŸ“é€šçŸ¥å†…å®¹
            message = self._render_template(template, variables)
            
            # ç¡®å®šé€šçŸ¥çº§åˆ«
            notification_level = self._get_notification_level(event_type)
            
            # å‘é€é€šçŸ¥åˆ°æ‰€æœ‰å¯ç”¨çš„æ¸ é“
            for channel_name, channel in self.channels.items():
                try:
                    if notification_level == 'error' or self._should_notify(channel_name, notification_level):
                        channel.send(message, task_config, notification_level)
                except Exception as e:
                    logger.error(f"é€šè¿‡ {channel_name} å‘é€é€šçŸ¥å¤±è´¥: {e}")
                    
        except Exception as e:
            logger.error(f"å‘é€é€šçŸ¥æ—¶å‘ç”Ÿé”™è¯¯: {e}")
    
    def _prepare_template_variables(self, task_config, event_type, *args, **kwargs):
        """å‡†å¤‡æ¨¡æ¿å˜é‡"""
        variables = {
            'task_name': task_config.name,
            'task_type': task_config.type,
            'task_id': task_config.task_id,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        
        # æ ¹æ®äº‹ä»¶ç±»å‹æ·»åŠ ç‰¹å®šå˜é‡
        if event_type == 'complete' and args:
            variables['duration'] = self._format_duration(args[0])
        
        if event_type == 'error' and 'error_message' in kwargs:
            variables['error_message'] = kwargs['error_message']
        
        if event_type == 'complete' and 'result_info' in kwargs:
            result_info = kwargs['result_info']
            if 'files_count' in result_info:
                variables['files_count'] = result_info['files_count']
            if 'issues_count' in result_info:
                variables['issues_count'] = result_info['issues_count']
            if 'inconsistencies_count' in result_info:
                variables['inconsistencies_count'] = result_info['inconsistencies_count']
        
        if event_type == 'issues_found' and 'issues_count' in kwargs:
            variables['issues_count'] = kwargs['issues_count']
        
        if event_type == 'critical_issues' and 'issues_description' in kwargs:
            variables['issues_description'] = kwargs['issues_description']
        
        return variables
    
    def _render_template(self, template, variables):
        """æ¸²æŸ“é€šçŸ¥æ¨¡æ¿"""
        try:
            return template.format(**variables)
        except KeyError as e:
            logger.warning(f"æ¨¡æ¿å˜é‡ç¼ºå¤±: {e}ï¼Œä½¿ç”¨åŸå§‹æ¨¡æ¿")
            return template
        except Exception as e:
            logger.error(f"æ¸²æŸ“æ¨¡æ¿æ—¶å‘ç”Ÿé”™è¯¯: {e}")
            return template
    
    def _get_notification_level(self, event_type):
        """è·å–é€šçŸ¥çº§åˆ«"""
        notification_levels = self.config.get('notification_levels', {})
        
        for level, events in notification_levels.items():
            if event_type in events:
                return level
        
        return 'info'  # é»˜è®¤ä¿¡æ¯çº§åˆ«
    
    def _should_notify(self, channel_name, notification_level):
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥å‘é€é€šçŸ¥"""
        # å¯ä»¥æ ¹æ®æ¸ é“å’Œé€šçŸ¥çº§åˆ«é…ç½®è¿‡æ»¤è§„åˆ™
        return True
    
    def _format_duration(self, duration_seconds):
        """æ ¼å¼åŒ–æ‰§è¡Œæ—¶é•¿"""
        if duration_seconds < 60:
            return f"{duration_seconds}ç§’"
        elif duration_seconds < 3600:
            minutes = duration_seconds // 60
            seconds = duration_seconds % 60
            return f"{minutes}åˆ†{seconds}ç§’"
        else:
            hours = duration_seconds // 3600
            minutes = (duration_seconds % 3600) // 60
            return f"{hours}å°æ—¶{minutes}åˆ†"

class DingTalkNotifier:
    """é’‰é’‰é€šçŸ¥å™¨"""
    
    def __init__(self, config):
        self.webhook_url = config['webhook_url']
        self.secret = config.get('secret', '')
        self.at_users = config.get('at_users', [])
        self.at_all = config.get('at_all', False)
    
    def send(self, message, task_config, notification_level):
        """å‘é€é’‰é’‰é€šçŸ¥"""
        try:
            # æ„å»ºé’‰é’‰æ¶ˆæ¯
            dingtalk_message = self._build_dingtalk_message(message, task_config, notification_level)
            
            # å‘é€HTTPè¯·æ±‚
            response = requests.post(
                self.webhook_url,
                json=dingtalk_message,
                headers={'Content-Type': 'application/json'}
            )
            
            if response.status_code == 200:
                logger.info(f"é’‰é’‰é€šçŸ¥å‘é€æˆåŠŸ: {message[:50]}...")
            else:
                logger.error(f"é’‰é’‰é€šçŸ¥å‘é€å¤±è´¥: {response.status_code} - {response.text}")
                
        except Exception as e:
            logger.error(f"å‘é€é’‰é’‰é€šçŸ¥æ—¶å‘ç”Ÿé”™è¯¯: {e}")
    
    def _build_dingtalk_message(self, message, task_config, notification_level):
        """æ„å»ºé’‰é’‰æ¶ˆæ¯"""
        # æ ¹æ®é€šçŸ¥çº§åˆ«é€‰æ‹©ä¸åŒçš„æ¶ˆæ¯ç±»å‹
        if notification_level == 'error':
            title = f"âŒ ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {task_config.name}"
            color = "#FF0000"  # çº¢è‰²
        elif notification_level == 'warning':
            title = f"âš ï¸ ä»»åŠ¡æ‰§è¡Œè­¦å‘Š: {task_config.name}"
            color = "#FFA500"  # æ©™è‰²
        else:
            title = f"â„¹ï¸ ä»»åŠ¡æ‰§è¡Œä¿¡æ¯: {task_config.name}"
            color = "#00FF00"  # ç»¿è‰²
        
        # æ„å»º@ç”¨æˆ·åˆ—è¡¨
        at_mobiles = []
        at_user_ids = []
        
        if self.at_all:
            at_mobiles.append('@all')
        else:
            for user in self.at_users:
                # è¿™é‡Œéœ€è¦æ ¹æ®ç”¨æˆ·åè·å–æ‰‹æœºå·æˆ–ç”¨æˆ·ID
                # ç®€åŒ–å®ç°ï¼Œç›´æ¥ä½¿ç”¨ç”¨æˆ·å
                at_user_ids.append(user)
        
        return {
            "msgtype": "markdown",
            "markdown": {
                "title": title,
                "text": f"### {title}\n\n{message}\n\n---\n\n**ä»»åŠ¡ID**: {task_config.task_id}\n**ä»»åŠ¡ç±»å‹**: {task_config.type}\n**æ‰§è¡Œæ—¶é—´**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            },
            "at": {
                "atMobiles": at_mobiles,
                "atUserIds": at_user_ids,
                "isAtAll": self.at_all
            }
        }
```

## 4. ä»»åŠ¡ç±»å‹å®ç°

### 4.1 ç¼–ç ä»»åŠ¡ (CodingTask)
```python
class CodingTask:
    """ç¼–ç ä»»åŠ¡å®ç°"""
    
    def __init__(self, config, ai_service, git_service):
        self.config = config
        self.ai_service = ai_service
        self.git_service = git_service
        self.state_manager = StateManager(config.task_id)
    
    def execute(self):
        """æ‰§è¡Œç¼–ç ä»»åŠ¡"""
        try:
            # 1. å‡†å¤‡å¼€å‘ç¯å¢ƒ
            self._prepare_environment()
            
            # 2. ç”Ÿæˆä»£ç 
            code_changes = self._generate_code()
            
            # 3. åº”ç”¨ä»£ç å˜æ›´
            self._apply_code_changes(code_changes)
            
            # 4. æäº¤ä»£ç 
            commit_hash = self._commit_code()
            
            # 5. æ›´æ–°çŠ¶æ€ä¸ºèµ°æŸ¥
            self.state_manager.transition_to_state("reviewing")
            
            # 6. é€šçŸ¥èµ°æŸ¥è€…
            self._notify_reviewer()
            
        except Exception as e:
            self._handle_error(e)
    
    def _generate_code(self):
        """ä½¿ç”¨AIç”Ÿæˆä»£ç """
        prompt = self._build_coding_prompt()
        response = self.ai_service.generate_code(
            model=self.config.ai.primary_model,
            prompt=prompt,
            context=self._get_code_context()
        )
        return self._parse_code_response(response)
    
    def _apply_code_changes(self, changes):
        """åº”ç”¨ä»£ç å˜æ›´"""
        for file_path, content in changes.items():
            full_path = os.path.join(self.config.project.path, file_path)
            os.makedirs(os.path.dirname(full_path), exist_ok=True)
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(content)
```

### 4.2 èµ°æŸ¥ä»»åŠ¡ (ReviewTask)
```python
class ReviewTask:
    """èµ°æŸ¥ä»»åŠ¡å®ç°"""
    
    def __init__(self, config, ai_service, git_service):
        self.config = config
        self.ai_service = ai_service
        self.git_service = git_service
        self.state_manager = StateManager(config.task_id)
    
    def execute(self):
        """æ‰§è¡Œèµ°æŸ¥ä»»åŠ¡"""
        try:
            # 1. è·å–ä»£ç å˜æ›´
            changes = self._get_code_changes()
            
            # 2. åˆ†æä»£ç è´¨é‡
            review_result = self._review_code(changes)
            
            # 3. ç”Ÿæˆèµ°æŸ¥æ„è§
            opinions = self._generate_review_opinions(review_result)
            
            # 4. è¾“å‡ºèµ°æŸ¥æŠ¥å‘Š
            self._output_review_report(opinions)
            
            # 5. åˆ¤æ–­æ˜¯å¦éœ€è¦ç»§ç»­ç¼–ç 
            if self._has_critical_issues(opinions):
                self.state_manager.transition_to_state("coding")
            else:
                self._complete_task()
                
        except Exception as e:
            self._handle_error(e)
    
    def _get_code_changes(self):
        """è·å–ä»£ç å˜æ›´"""
        if self.config.is_collaborative:
            # åä½œæ¨¡å¼ï¼šè·å–ç¼–ç ä»»åŠ¡çš„å˜æ›´
            return self._get_collaborative_changes()
        else:
            # ç‹¬ç«‹æ¨¡å¼ï¼šè·å–æŒ‡å®šåˆ†æ”¯çš„å˜æ›´
            return self._get_branch_changes()
    
    def _review_code(self, changes):
        """AIä»£ç å®¡æŸ¥"""
        # è·å–ç¼–ç è§„èŒƒ
        coding_standards = self._load_coding_standards()
        
        # è·å–AIå‚æ•°
        ai_parameters = self.config_manager.get_ai_parameters(
            self.config.ai.primary_model, 
            'review'
        )
        
        prompt = self._build_review_prompt(changes, coding_standards)
        response = self.ai_service.review_code(
            model=self.config.ai.primary_model,
            prompt=prompt,
            code_changes=changes,
            coding_standards=coding_standards,
            parameters=ai_parameters
        )
        return self._parse_review_response(response)
    
    def _load_coding_standards(self):
        """åŠ è½½ç¼–ç è§„èŒƒ"""
        # ä»é…ç½®ç®¡ç†å™¨è·å–ç¼–ç è§„èŒƒ
        standards = self.config_manager.get_coding_standards()
        
        # æ ¹æ®é¡¹ç›®ç±»å‹é€‰æ‹©åˆé€‚çš„è§„èŒƒ
        project_type = self._detect_project_type()
        if project_type in standards:
            return standards[project_type]['content']
        
        # å›é€€åˆ°é€šç”¨è§„èŒƒ
        return standards.get('general', {}).get('content', '')
    
    def _detect_project_type(self):
        """æ£€æµ‹é¡¹ç›®ç±»å‹"""
        # æ ¹æ®é¡¹ç›®æ–‡ä»¶ç»“æ„æ£€æµ‹é¡¹ç›®ç±»å‹
        project_path = self.config.project.path
        
        if os.path.exists(os.path.join(project_path, 'pom.xml')):
            return 'java'
        elif os.path.exists(os.path.join(project_path, 'requirements.txt')):
            return 'python'
        elif os.path.exists(os.path.join(project_path, 'package.json')):
            return 'frontend'
        else:
            return 'general'
```

### 4.3 éœ€æ±‚è¯„å®¡ä»»åŠ¡ (RequirementReviewTask)
```python
class RequirementReviewTask:
    """éœ€æ±‚è¯„å®¡ä»»åŠ¡å®ç°"""
    
    def __init__(self, config, ai_service, git_service):
        self.config = config
        self.ai_service = ai_service
        self.git_service = git_service
    
    def execute(self):
        """æ‰§è¡Œéœ€æ±‚è¯„å®¡ä»»åŠ¡"""
        try:
            # 1. è¯»å–éœ€æ±‚æ–‡æ¡£
            requirement_doc = self._read_requirement_document()
            
            # 2. è·å–ä»£ç å®ç°
            code_implementation = self._get_code_implementation()
            
            # 3. AIåˆ†æéœ€æ±‚ä¸ä»£ç çš„ä¸€è‡´æ€§
            review_result = self._analyze_requirement_code_consistency(
                requirement_doc, code_implementation
            )
            
            # 4. ç”Ÿæˆè¯„å®¡æ„è§
            review_opinions = self._generate_review_opinions(review_result)
            
            # 5. è¾“å‡ºè¯„å®¡æŠ¥å‘Š
            self._output_review_report(review_opinions)
            
        except Exception as e:
            self._handle_error(e)
    
    def _read_requirement_document(self):
        """è¯»å–éœ€æ±‚æ–‡æ¡£"""
        doc_path = self.config.requirement.document_path
        doc_type = self.config.requirement.document_type
        
        if doc_type == "markdown":
            with open(doc_path, 'r', encoding='utf-8') as f:
                return f.read()
        elif doc_type == "word":
            # ä½¿ç”¨python-docxè¯»å–Wordæ–‡æ¡£
            from docx import Document
            doc = Document(doc_path)
            return '\n'.join([paragraph.text for paragraph in doc.paragraphs])
        else:
            raise ValueError(f"Unsupported document type: {doc_type}")
    
    def _get_code_implementation(self):
        """è·å–ä»£ç å®ç°"""
        project_path = self.config.code_reference.project_path
        branch = self.config.code_reference.branch
        package_paths = self.config.code_reference.package_paths
        
        # åˆ‡æ¢åˆ°æŒ‡å®šåˆ†æ”¯
        self.git_service.checkout_branch(project_path, branch)
        
        # è¯»å–æŒ‡å®šåŒ…è·¯å¾„çš„ä»£ç 
        code_content = {}
        for package_path in package_paths:
            full_path = os.path.join(project_path, package_path)
            if os.path.exists(full_path):
                code_content[package_path] = self._read_package_code(full_path)
        
        return code_content
    
    def _analyze_requirement_code_consistency(self, requirement_doc, code_implementation):
        """AIåˆ†æéœ€æ±‚ä¸ä»£ç çš„ä¸€è‡´æ€§"""
        prompt = self._build_analysis_prompt(requirement_doc, code_implementation)
        response = self.ai_service.analyze_requirement_code(
            model=self.config.ai.primary_model,
            prompt=prompt,
            requirement_doc=requirement_doc,
            code_implementation=code_implementation
        )
        return self._parse_analysis_response(response)
```

### 4.4 è‡ªå®šä¹‰ä»»åŠ¡ (CustomTask)
```python
class CustomTask:
    """è‡ªå®šä¹‰ä»»åŠ¡å®ç°"""
    
    def __init__(self, config, ai_service, git_service):
        self.config = config
        self.ai_service = ai_service
        self.git_service = git_service
    
    def execute(self):
        """æ‰§è¡Œè‡ªå®šä¹‰ä»»åŠ¡"""
        try:
            # 1. å‡†å¤‡è¾“å…¥æ•°æ®
            input_data = self._prepare_input_data()
            
            # 2. æ„å»ºAIæç¤ºè¯
            prompt = self._build_custom_prompt(input_data)
            
            # 3. è°ƒç”¨AIæœåŠ¡
            ai_response = self.ai_service.execute_custom_task(
                model=self.config.ai.primary_model,
                prompt=prompt,
                input_data=input_data
            )
            
            # 4. å¤„ç†AIå“åº”
            processed_result = self._process_ai_response(ai_response)
            
            # 5. è¾“å‡ºç»“æœ
            self._output_result(processed_result)
            
        except Exception as e:
            self._handle_error(e)
    
    def _prepare_input_data(self):
        """å‡†å¤‡è¾“å…¥æ•°æ®"""
        input_sources = self.config.task_objective.input_sources
        input_data = {}
        
        for source in input_sources:
            if os.path.isfile(source):
                # è¯»å–æ–‡ä»¶å†…å®¹
                with open(source, 'r', encoding='utf-8') as f:
                    input_data[os.path.basename(source)] = f.read()
            elif os.path.isdir(source):
                # è¯»å–ç›®å½•å†…å®¹
                input_data[os.path.basename(source)] = self._read_directory_content(source)
        
        return input_data
    
    def _output_result(self, result):
        """è¾“å‡ºç»“æœ"""
        output_format = self.config.output.format
        output_path = self.config.output.output_path
        filename_template = self.config.output.filename_template
        
        # ç”Ÿæˆæ–‡ä»¶å
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = filename_template.format(timestamp=timestamp)
        
        if output_format == "markdown":
            file_path = os.path.join(output_path, f"{filename}.md")
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(result)
        elif output_format == "excel":
            # ä½¿ç”¨pandasç”ŸæˆExcelæ–‡ä»¶
            import pandas as pd
            file_path = os.path.join(output_path, f"{filename}.xlsx")
            # è¿™é‡Œéœ€è¦æ ¹æ®resultçš„ç»“æ„æ¥ç”ŸæˆExcel
            # å…·ä½“å®ç°æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´
        elif output_format == "ppt":
            # ä½¿ç”¨python-pptxç”ŸæˆPPTæ–‡ä»¶
            from pptx import Presentation
            file_path = os.path.join(output_path, f"{filename}.pptx")
            # è¿™é‡Œéœ€è¦æ ¹æ®resultçš„ç»“æ„æ¥ç”ŸæˆPPT
            # å…·ä½“å®ç°æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´
```

## 5. æœåŠ¡å±‚è®¾è®¡

### 5.1 AIæœåŠ¡ç®¡ç†å™¨ (AIService)
```python
class AIService:
    """AIæœåŠ¡ç®¡ç†å™¨ï¼Œæ”¯æŒå¤šä¸ªAIæ¨¡å‹"""
    
    def __init__(self, config):
        self.config = config
        self.clients = self._initialize_clients()
    
    def _initialize_clients(self):
        """åˆå§‹åŒ–AIå®¢æˆ·ç«¯"""
        clients = {}
        
        # Claudeå®¢æˆ·ç«¯
        if self.config.ai_services.claude.api_key:
            clients['claude'] = ClaudeClient(
                api_key=self.config.ai_services.claude.api_key,
                base_url=self.config.ai_services.claude.base_url,
                model=self.config.ai_services.claude.model
            )
        
        # DeepSeekå®¢æˆ·ç«¯
        if self.config.ai_services.deepseek.api_key:
            clients['deepseek'] = DeepSeekClient(
                api_key=self.config.ai_services.deepseek.api_key,
                base_url=self.config.ai_services.deepseek.base_url,
                model=self.config.ai_services.deepseek.model
            )
        
        return clients
    
    def generate_code(self, model, prompt, context=None):
        """ç”Ÿæˆä»£ç """
        client = self.clients.get(model)
        if not client:
            raise ValueError(f"Unsupported AI model: {model}")
        
        try:
            response = client.generate_code(prompt, context)
            return response
        except Exception as e:
            # å°è¯•ä½¿ç”¨å¤‡ç”¨æ¨¡å‹
            fallback_model = self._get_fallback_model(model)
            if fallback_model and fallback_model != model:
                return self.generate_code(fallback_model, prompt, context)
            raise e
    
    def review_code(self, model, prompt, code_changes, coding_standards):
        """ä»£ç å®¡æŸ¥"""
        client = self.clients.get(model)
        if not client:
            raise ValueError(f"Unsupported AI model: {model}")
        
        return client.review_code(prompt, code_changes, coding_standards)
    
    def analyze_requirement_code(self, model, prompt, requirement_doc, code_implementation):
        """éœ€æ±‚ä¸ä»£ç ä¸€è‡´æ€§åˆ†æ"""
        client = self.clients.get(model)
        if not client:
            raise ValueError(f"Unsupported AI model: {model}")
        
        return client.analyze_requirement_code(prompt, requirement_doc, code_implementation)
    
    def execute_custom_task(self, model, prompt, input_data):
        """æ‰§è¡Œè‡ªå®šä¹‰ä»»åŠ¡"""
        client = self.clients.get(model)
        if not client:
            raise ValueError(f"Unsupported AI model: {model}")
        
        return client.execute_custom_task(prompt, input_data)
```

### 5.2 Gitæ“ä½œæœåŠ¡ (GitService)
```python
class GitService:
    """Gitæ“ä½œæœåŠ¡ï¼Œæ”¯æŒGitHubå’ŒGitLab"""
    
    def __init__(self, config):
        self.config = config
        self.github_client = self._init_github_client()
        self.gitlab_client = self._init_gitlab_client()
    
    def _init_github_client(self):
        """åˆå§‹åŒ–GitHubå®¢æˆ·ç«¯"""
        if self.config.git.github.token:
            return Github(self.config.git.github.token)
        return None
    
    def _init_gitlab_client(self):
        """åˆå§‹åŒ–GitLabå®¢æˆ·ç«¯"""
        if self.config.git.gitlab.token:
            return gitlab.Gitlab(
                url=self.config.git.gitlab.base_url,
                private_token=self.config.git.gitlab.token
            )
        return None
    
    def create_branch(self, project_path, base_branch, new_branch):
        """åˆ›å»ºæ–°åˆ†æ”¯"""
        repo = git.Repo(project_path)
        
        # ç¡®ä¿æœ¬åœ°æ˜¯æœ€æ–°çš„
        repo.remotes.origin.fetch()
        
        # åˆ›å»ºæ–°åˆ†æ”¯
        new_branch_ref = repo.create_head(new_branch, f"origin/{base_branch}")
        new_branch_ref.checkout()
        
        return new_branch_ref
    
    def commit_changes(self, project_path, commit_message, files=None):
        """æäº¤ä»£ç å˜æ›´"""
        repo = git.Repo(project_path)
        
        # æ·»åŠ æ‰€æœ‰å˜æ›´
        if files:
            for file_path in files:
                repo.index.add([file_path])
        else:
            repo.index.add(['*'])
        
        # æäº¤
        commit = repo.index.commit(commit_message)
        
        # æ¨é€åˆ°è¿œç¨‹
        repo.remotes.origin.push()
        
        return commit.hexsha
    
    def get_changes_since(self, project_path, branch, since_date):
        """è·å–æŒ‡å®šæ—¶é—´ä¹‹åçš„ä»£ç å˜æ›´"""
        repo = git.Repo(project_path)
        
        # è·å–æŒ‡å®šåˆ†æ”¯
        branch_ref = repo.heads[branch]
        branch_ref.checkout()
        
        # è·å–æŒ‡å®šæ—¶é—´ä¹‹åçš„æäº¤
        since_timestamp = datetime.strptime(since_date, "%Y-%m-%d").timestamp()
        commits = []
        
        for commit in repo.iter_commits(branch):
            if commit.committed_date >= since_timestamp:
                commits.append({
                    'hash': commit.hexsha,
                    'author': commit.author.name,
                    'date': datetime.fromtimestamp(commit.committed_date),
                    'message': commit.message,
                    'files': list(commit.stats.files.keys())
                })
        
        return commits
```

## 6. å‘½ä»¤è¡Œæ¥å£è®¾è®¡

### 6.1 ä¸»ç¨‹åºå…¥å£ (main.py)
```python
import click
import yaml
import json
from pathlib import Path

@click.group()
def cli():
    """è‡ªåŠ¨åŒ–AIä»»åŠ¡æ‰§è¡Œç³»ç»Ÿ"""
    pass

@cli.command()
@click.option('--config', '-c', default='config/global_config.yaml', help='é…ç½®æ–‡ä»¶è·¯å¾„')
@click.option('--daemon', '-d', is_flag=True, help='ä»¥å®ˆæŠ¤è¿›ç¨‹æ¨¡å¼è¿è¡Œ')
def start(config, daemon):
    """å¯åŠ¨ä»»åŠ¡è°ƒåº¦å™¨"""
    click.echo(f"å¯åŠ¨ä»»åŠ¡è°ƒåº¦å™¨ï¼Œé…ç½®æ–‡ä»¶: {config}")
    
    # åŠ è½½é…ç½®
    config_manager = ConfigManager(config)
    
    # å¯åŠ¨è°ƒåº¦å™¨
    scheduler = TaskScheduler(config_manager)
    scheduler.start()
    
    if daemon:
        click.echo("ä»¥å®ˆæŠ¤è¿›ç¨‹æ¨¡å¼è¿è¡Œ...")
        # å®ç°å®ˆæŠ¤è¿›ç¨‹é€»è¾‘
    else:
        click.echo("æŒ‰ Ctrl+C åœæ­¢...")
        try:
            scheduler.wait()
        except KeyboardInterrupt:
            click.echo("æ­£åœ¨åœæ­¢...")
            scheduler.stop()

@cli.command()
@click.argument('task_id')
def status(task_id):
    """æŸ¥çœ‹ä»»åŠ¡çŠ¶æ€"""
    state_file = Path(f"states/{task_id}.json")
    if state_file.exists():
        with open(state_file, 'r', encoding='utf-8') as f:
            state = json.load(f)
        
        click.echo(f"ä»»åŠ¡ID: {state['task_id']}")
        click.echo(f"ä»»åŠ¡åç§°: {state['task_name']}")
        click.echo(f"å½“å‰çŠ¶æ€: {state['current_state']}")
        click.echo(f"çŠ¶æ€: {state['status']}")
        click.echo(f"å½“å‰è½®æ¬¡: {state['current_round']}")
        click.echo(f"æœ€åæ›´æ–°: {state['last_update']}")
    else:
        click.echo(f"ä»»åŠ¡ {task_id} ä¸å­˜åœ¨")

@cli.command()
@click.argument('task_id')
def trigger(task_id):
    """æ‰‹åŠ¨è§¦å‘ä»»åŠ¡"""
    click.echo(f"æ‰‹åŠ¨è§¦å‘ä»»åŠ¡: {task_id}")
    
    # è·å–ä»»åŠ¡é…ç½®
    config_manager = ConfigManager()
    task_config = config_manager.get_task_config(task_id)
    
    if task_config:
        # åˆ›å»ºæ‰§è¡Œå™¨å¹¶æ‰§è¡Œ
        executor = TaskExecutor(task_id, config_manager)
        executor.start()
        click.echo("ä»»åŠ¡å·²è§¦å‘")
    else:
        click.echo(f"ä»»åŠ¡ {task_id} é…ç½®ä¸å­˜åœ¨")

@cli.command()
@click.argument('task_id')
def stop(task_id):
    """åœæ­¢æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡"""
    click.echo(f"åœæ­¢ä»»åŠ¡: {task_id}")
    
    # å®ç°ä»»åŠ¡åœæ­¢é€»è¾‘
    state_manager = StateManager(task_id)
    state_manager.update_state({'status': 'stopped'})
    click.echo("ä»»åŠ¡å·²åœæ­¢")

@cli.command()
def list():
    """åˆ—å‡ºæ‰€æœ‰ä»»åŠ¡"""
    config_dir = Path("config/tasks")
    if config_dir.exists():
        for config_file in config_dir.glob("*.yaml"):
            with open(config_file, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
            
            click.echo(f"ä»»åŠ¡ID: {config.get('task_id', 'N/A')}")
            click.echo(f"ä»»åŠ¡åç§°: {config.get('name', 'N/A')}")
            click.echo(f"ä»»åŠ¡ç±»å‹: {config.get('type', 'N/A')}")
            click.echo(f"å¯ç”¨çŠ¶æ€: {config.get('enabled', False)}")
            click.echo("---")
    else:
        click.echo("æ²¡æœ‰æ‰¾åˆ°ä»»åŠ¡é…ç½®æ–‡ä»¶")

if __name__ == '__main__':
    cli()
```

## 7. éƒ¨ç½²å’Œè¿è¡Œ

### 7.1 ä¾èµ–å®‰è£…
```bash
# å®‰è£…Pythonä¾èµ–
pip install -r requirements.txt

# å®‰è£…Gitå®¢æˆ·ç«¯ï¼ˆWindowsï¼‰
# ä¸‹è½½å¹¶å®‰è£… Git for Windows
```

### 7.2 ç¯å¢ƒå˜é‡é…ç½®
```bash
# è®¾ç½®ç¯å¢ƒå˜é‡
set CLAUDE_API_KEY=your_claude_api_key
set DEEPSEEK_API_KEY=your_deepseek_api_key
set GITHUB_TOKEN=your_github_token
set GITHUB_USERNAME=your_github_username
set GITLAB_TOKEN=your_gitlab_token
set GITLAB_BASE_URL=your_gitlab_url
set DINGTALK_WEBHOOK=your_dingtalk_webhook
set DINGTALK_SECRET=your_dingtalk_secret
```

### 7.3 å¯åŠ¨ç³»ç»Ÿ
```bash
# å¯åŠ¨ä»»åŠ¡è°ƒåº¦å™¨
python src/cli/main.py start

# æŸ¥çœ‹ä»»åŠ¡çŠ¶æ€
python src/cli/main.py status task_001

# æ‰‹åŠ¨è§¦å‘ä»»åŠ¡
python src/cli/main.py trigger task_001

# åˆ—å‡ºæ‰€æœ‰ä»»åŠ¡
python src/cli/main.py list
```

## 8. ç›‘æ§å’Œæ—¥å¿—

### 8.1 æ—¥å¿—æ ¼å¼
```
2025-01-20 09:00:00,123 - INFO - [TaskExecutor] å¼€å§‹æ‰§è¡Œä»»åŠ¡: task_001
2025-01-20 09:00:05,456 - INFO - [CodingTask] ä»£ç ç”Ÿæˆå®Œæˆï¼Œæ–‡ä»¶æ•°: 3
2025-01-20 09:00:10,789 - INFO - [GitService] ä»£ç æäº¤æˆåŠŸï¼Œcommit: abc123
2025-01-20 09:00:11,012 - INFO - [StateManager] çŠ¶æ€æ›´æ–°: coding -> reviewing
```

### 8.2 ç›‘æ§æŒ‡æ ‡
- ä»»åŠ¡æ‰§è¡ŒæˆåŠŸç‡
- ä»»åŠ¡æ‰§è¡Œæ—¶é—´
- AI APIè°ƒç”¨æ¬¡æ•°å’ŒæˆåŠŸç‡
- Gitæ“ä½œæˆåŠŸç‡
- ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ

## 9. å®‰å…¨è€ƒè™‘

### 9.1 APIå¯†é’¥ç®¡ç†
- ä½¿ç”¨ç¯å¢ƒå˜é‡å­˜å‚¨æ•æ„Ÿä¿¡æ¯
- æ—¥å¿—ä¸­è‡ªåŠ¨è„±æ•APIå¯†é’¥
- æ”¯æŒå¯†é’¥è½®æ¢

### 9.2 è®¿é—®æ§åˆ¶
- Gitæ“ä½œä½¿ç”¨æœ€å°æƒé™åŸåˆ™
- æ”¯æŒSSHå¯†é’¥è®¤è¯
- æ“ä½œå®¡è®¡æ—¥å¿—

## 10. æ‰©å±•æ€§è®¾è®¡

### 10.1 æ–°AIæ¨¡å‹æ”¯æŒ
- æ’ä»¶åŒ–çš„AIæœåŠ¡æ¥å£
- é…ç½®æ–‡ä»¶é©±åŠ¨çš„æ¨¡å‹é€‰æ‹©
- æ”¯æŒè‡ªå®šä¹‰AIæœåŠ¡

### 10.2 æ–°ä»»åŠ¡ç±»å‹
- åŸºäºæ¥å£çš„ä»»åŠ¡ç±»å‹å®šä¹‰
- æ’ä»¶åŒ–çš„ä»»åŠ¡å®ç°
- æ”¯æŒè‡ªå®šä¹‰ä»»åŠ¡é€»è¾‘

## 11. æ€»ç»“

æœ¬è®¾è®¡æ–‡æ¡£è¯¦ç»†æè¿°äº†è‡ªåŠ¨åŒ–AIä»»åŠ¡æ‰§è¡Œç³»ç»Ÿçš„æ¶æ„è®¾è®¡ã€æ ¸å¿ƒæ¨¡å—ã€é…ç½®ç®¡ç†ã€éƒ¨ç½²è¿è¡Œç­‰å„ä¸ªæ–¹é¢ã€‚ç³»ç»Ÿé‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œå…·æœ‰è‰¯å¥½çš„æ‰©å±•æ€§å’Œç»´æŠ¤æ€§ï¼Œèƒ½å¤Ÿæ»¡è¶³5ç§ä»»åŠ¡ç±»å‹çš„è‡ªåŠ¨åŒ–æ‰§è¡Œéœ€æ±‚ã€‚

### ç³»ç»Ÿæ”¯æŒçš„5ç§ä»»åŠ¡ç±»å‹

1. **ç¼–ç ä»»åŠ¡ (coding)**ï¼šAIè‡ªåŠ¨ç”Ÿæˆä»£ç ï¼Œæ”¯æŒåˆ†æ”¯åˆ›å»ºå’ŒGitæäº¤
2. **èµ°æŸ¥ä»»åŠ¡ (review)**ï¼šAIä»£ç å®¡æŸ¥ï¼Œåˆ†æä»£ç è´¨é‡å’Œè®¾è®¡åˆç†æ€§
3. **æ–‡æ¡£ä»»åŠ¡ (doc)**ï¼šAIè‡ªåŠ¨ç”ŸæˆMarkdownæ ¼å¼æ–‡æ¡£
4. **éœ€æ±‚è¯„å®¡ä»»åŠ¡ (requirement_review)**ï¼šAIåˆ†æéœ€æ±‚æ–‡æ¡£ä¸ä»£ç å®ç°çš„ä¸€è‡´æ€§
5. **è‡ªå®šä¹‰ä»»åŠ¡ (custom)**ï¼šæ”¯æŒä»»æ„åœºæ™¯çš„AIä»»åŠ¡ï¼Œé«˜åº¦çµæ´»

### ç³»ç»Ÿçš„ä¸»è¦ç‰¹ç‚¹

1. **çµæ´»çš„è°ƒåº¦æœºåˆ¶**ï¼šæ”¯æŒcrontabè¡¨è¾¾å¼çš„å®šæ—¶ä»»åŠ¡æ‰§è¡Œï¼Œæ”¯æŒä¼˜å…ˆçº§å’Œå¹¶å‘æ§åˆ¶
2. **æ™ºèƒ½çš„çŠ¶æ€åè°ƒ**ï¼šé€šè¿‡çŠ¶æ€æ–‡ä»¶å®ç°ç¼–ç è€…å’Œèµ°æŸ¥è€…çš„åä½œï¼Œæ”¯æŒè‡ªåŠ¨çŠ¶æ€è½¬æ¢
3. **å¤šAIæ¨¡å‹æ”¯æŒ**ï¼šæ”¯æŒClaudeå’ŒDeepSeekç­‰å¤šç§AIæ¨¡å‹ï¼Œæ”¯æŒä»»åŠ¡ç±»å‹ç‰¹å®šçš„å‚æ•°ä¼˜åŒ–
4. **å®Œæ•´çš„Gité›†æˆ**ï¼šæ”¯æŒGitHubå’ŒGitLabçš„è‡ªåŠ¨åŒ–æ“ä½œï¼ŒåŒ…æ‹¬åˆ†æ”¯ç®¡ç†å’Œä»£ç æäº¤
5. **ä¸°å¯Œçš„é€šçŸ¥æœºåˆ¶**ï¼šæ”¯æŒé’‰é’‰æœºå™¨äººé€šçŸ¥ï¼Œä¸ªæ€§åŒ–é€šçŸ¥æ¨¡æ¿å’Œå¤šç§é€šçŸ¥çº§åˆ«
6. **å‹å¥½çš„å‘½ä»¤è¡Œæ¥å£**ï¼šæä¾›å®Œæ•´çš„ä»»åŠ¡ç®¡ç†åŠŸèƒ½ï¼Œæ”¯æŒä»»åŠ¡çŠ¶æ€æŸ¥çœ‹å’Œæ‰‹åŠ¨è§¦å‘
7. **ç»Ÿä¸€çš„ä»»åŠ¡ç®¡ç†**ï¼šæ‰€æœ‰ä»»åŠ¡ç±»å‹ä½¿ç”¨ç»Ÿä¸€çš„é…ç½®å’Œè°ƒåº¦æœºåˆ¶
8. **çµæ´»çš„è¾“å…¥è¾“å‡º**ï¼šæ”¯æŒå¤šç§æ–‡æ¡£æ ¼å¼å’Œè¾“å‡ºæ ¼å¼
9. **æ™ºèƒ½çš„é…ç½®ç®¡ç†**ï¼šæ”¯æŒç¼–ç è§„èŒƒã€è¶…æ—¶æ—¶é—´ã€é‡è¯•ç­–ç•¥ç­‰è¯¦ç»†é…ç½®
10. **å®Œå–„çš„çŠ¶æ€ç®¡ç†**ï¼šè‡ªåŠ¨æ¸…ç†ã€å½’æ¡£å’Œå¤‡ä»½ï¼Œæ”¯æŒå‹ç¼©å’Œç‰ˆæœ¬ç®¡ç†

### åº”ç”¨åœºæ™¯

é€šè¿‡è¿™ä¸ªç³»ç»Ÿï¼Œç”¨æˆ·å¯ä»¥è‡ªåŠ¨åŒ–åœ°å®Œæˆï¼š
- **ä»£ç å¼€å‘**ï¼šAIè¾…åŠ©ç¼–ç ï¼Œè‡ªåŠ¨åˆ†æ”¯ç®¡ç†å’Œä»£ç æäº¤
- **ä»£ç å®¡æŸ¥**ï¼šAIä»£ç è´¨é‡åˆ†æï¼Œè®¾è®¡åˆç†æ€§è¯„ä¼°
- **æ–‡æ¡£ç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”ŸæˆæŠ€æœ¯æ–‡æ¡£ã€APIæ–‡æ¡£ç­‰
- **éœ€æ±‚è¯„å®¡**ï¼šAIåˆ†æéœ€æ±‚ä¸ä»£ç çš„ä¸€è‡´æ€§ï¼Œå‘ç°è®¾è®¡é—®é¢˜
- **è‡ªå®šä¹‰åˆ†æ**ï¼šæ ¹æ®å…·ä½“éœ€æ±‚å®šåˆ¶AIåˆ†æä»»åŠ¡

### é…ç½®ç®¡ç†ç‰¹æ€§

ç³»ç»Ÿæä¾›äº†å…¨é¢çš„é…ç½®ç®¡ç†èƒ½åŠ›ï¼Œæ”¯æŒä»¥ä¸‹é…ç½®é¡¹ï¼š

#### ç¼–ç è§„èŒƒé…ç½®
- **æŒ‰è¯­è¨€åˆ†ç±»**ï¼šæ”¯æŒJavaã€Pythonã€å‰ç«¯ç­‰è¯­è¨€çš„ç‹¬ç«‹ç¼–ç è§„èŒƒæ–‡ä»¶
- **ç‰ˆæœ¬ç®¡ç†**ï¼šç¼–ç è§„èŒƒæ–‡ä»¶æ”¯æŒç‰ˆæœ¬å·å’Œæ›´æ–°æ—¶é—´è®°å½•
- **åŠ¨æ€åŠ è½½**ï¼šç³»ç»Ÿè¿è¡Œæ—¶åŠ¨æ€åŠ è½½ç¼–ç è§„èŒƒï¼Œæ”¯æŒçƒ­æ›´æ–°
- **æ™ºèƒ½é€‰æ‹©**ï¼šæ ¹æ®é¡¹ç›®ç±»å‹è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„ç¼–ç è§„èŒƒ

#### ä»»åŠ¡è¶…æ—¶é…ç½®
- **ä»»åŠ¡ç±»å‹ç‰¹å®š**ï¼šä¸ºä¸åŒä»»åŠ¡ç±»å‹è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
- **å…¨å±€é…ç½®**ï¼šæ”¯æŒå…¨å±€é»˜è®¤è¶…æ—¶å’Œæœ€å¤§è¶…æ—¶é™åˆ¶
- **è­¦å‘Šé˜ˆå€¼**ï¼šæ”¯æŒè¶…æ—¶è­¦å‘Šé˜ˆå€¼é…ç½®ï¼Œæå‰å‘å‡ºè¶…æ—¶æé†’
- **çµæ´»è°ƒæ•´**ï¼šæ”¯æŒè¿è¡Œæ—¶è°ƒæ•´è¶…æ—¶é…ç½®

#### AIå‚æ•°ä¼˜åŒ–
- **æ¨¡å‹ç‰¹å®šå‚æ•°**ï¼šæ”¯æŒClaudeå’ŒDeepSeekçš„ç‰¹å®šå‚æ•°é…ç½®
- **ä»»åŠ¡ç±»å‹ä¼˜åŒ–**ï¼šä¸ºä¸åŒä»»åŠ¡ç±»å‹ä¼˜åŒ–AIå‚æ•°ï¼Œæé«˜æ‰§è¡Œæ•ˆæœ
- **å‚æ•°ç»§æ‰¿**ï¼šæ”¯æŒå‚æ•°ç»§æ‰¿å’Œè¦†ç›–æœºåˆ¶
- **åŠ¨æ€è°ƒæ•´**ï¼šæ”¯æŒæ ¹æ®ä»»åŠ¡å¤æ‚åº¦åŠ¨æ€è°ƒæ•´AIå‚æ•°

#### é‡è¯•ç­–ç•¥é…ç½®
- **æŒ‡æ•°é€€é¿**ï¼šæ”¯æŒæŒ‡æ•°é€€é¿é‡è¯•æœºåˆ¶ï¼Œé¿å…é¢‘ç¹é‡è¯•
- **ä»»åŠ¡ç‰¹å®šç­–ç•¥**ï¼šä¸ºä¸åŒä»»åŠ¡ç±»å‹é…ç½®ä¸åŒçš„é‡è¯•ç­–ç•¥
- **éšæœºæŠ–åŠ¨**ï¼šæ”¯æŒéšæœºæŠ–åŠ¨å› å­ï¼Œé¿å…é›ªå´©æ•ˆåº”
- **æ™ºèƒ½é‡è¯•**ï¼šæ”¯æŒæ ¹æ®é”™è¯¯ç±»å‹æ™ºèƒ½å†³å®šæ˜¯å¦é‡è¯•

#### é€šçŸ¥æ¨¡æ¿é…ç½®
- **ä¸ªæ€§åŒ–æ¨¡æ¿**ï¼šæ”¯æŒä¸åŒä»»åŠ¡ç±»å‹ä½¿ç”¨ä¸åŒçš„é€šçŸ¥æ¨¡æ¿
- **å¤šçº§åˆ«é€šçŸ¥**ï¼šæ”¯æŒä¿¡æ¯ã€è­¦å‘Šã€é”™è¯¯ç­‰ä¸åŒçº§åˆ«çš„é€šçŸ¥
- **å˜é‡æ”¯æŒ**ï¼šæ”¯æŒåŠ¨æ€å˜é‡æ›¿æ¢ï¼Œæä¾›ä¸°å¯Œçš„é€šçŸ¥å†…å®¹
- **å¤šæ¸ é“æ”¯æŒ**ï¼šæ”¯æŒé’‰é’‰ã€é‚®ä»¶ã€Webhookç­‰å¤šç§é€šçŸ¥æ¸ é“

#### çŠ¶æ€ç®¡ç†é…ç½®
- **è‡ªåŠ¨æ¸…ç†**ï¼šæ”¯æŒå‡Œæ™¨2ç‚¹è‡ªåŠ¨æ¸…ç†è¿‡æœŸçŠ¶æ€æ–‡ä»¶
- **æ™ºèƒ½å½’æ¡£**ï¼šæ”¯æŒé‡è¦çŠ¶æ€ä¿¡æ¯çš„è‡ªåŠ¨å½’æ¡£å’Œå‹ç¼©
- **å¤‡ä»½ç­–ç•¥**ï¼šæ”¯æŒçŠ¶æ€æ–‡ä»¶çš„è‡ªåŠ¨å¤‡ä»½å’Œç‰ˆæœ¬ç®¡ç†
- **æ¸…ç†ç­–ç•¥**ï¼šæ”¯æŒé’ˆå¯¹ä¸åŒçŠ¶æ€ä»»åŠ¡çš„å·®å¼‚åŒ–æ¸…ç†ç­–ç•¥

ç³»ç»Ÿèƒ½å¤Ÿå¤§å¤§æé«˜å¼€å‘æ•ˆç‡ã€ä»£ç è´¨é‡å’Œé¡¹ç›®ç®¡ç†æ°´å¹³ï¼Œæ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„AIè¾…åŠ©å¼€å‘å¹³å°ã€‚
